<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>On-the-fly time-dependent mesh adaptation &#8212; Animate, Movement, Goalie and UM2N 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <script src="../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Animate, Movement, Goalie and UM2N 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">On-the-fly time-dependent mesh adaptation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="on-the-fly-time-dependent-mesh-adaptation">
<h1>On-the-fly time-dependent mesh adaptation<a class="headerlink" href="#on-the-fly-time-dependent-mesh-adaptation" title="Link to this heading">¶</a></h1>
<p>In this demo we consider the two-dimensional version of the mesh adaptation experiment
presented in <span id="id1">[]</span>. The problem comprises a bubble of tracer
concentration field advected by a time-varying flow.
We will consider two different mesh adaptation strategies: the classical mesh
adaptation algorithm, which adapts the mesh several times throughout the simulation
based on the solution at the current time, and the metric advection algorithm, which
advects the initial metric tensor along the flow in order to predict where to
prescribe fine resolution in the future. Both algorithms are an example of
<em>on-the-fly</em> time-dependent mesh adaptation algorithms, where the mesh is adapted
before each subinterval of the simulation, as opposed to fixed-point iteration
algorithms. Fixed-point iteration algorithms solve the equation of interest at each
iteration, before adapting the mesh based on computed solutions at the end of each
iteration. This clearly makes them effective at predicting where to prescribe fine
resolution throughout the simulation, but implies substantial computational cost.</p>
<p>We begin by defining the advection problem. We consider the advection equation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rl}
    \frac{\partial c}{\partial t} + \nabla\cdot(\mathbf{u}c)=0&amp; \text{in}\:\Omega,\\
    c=0 &amp; \text{on}\:\partial\Omega,\\
    c=c_0(x,y) &amp; \text{at}\:t=0,
\end{array},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(c=c(x,y,t)\)</span> is the sought tracer concentration,
<span class="math notranslate nohighlight">\(\mathbf{u}=\mathbf{u}(x,y,t)\)</span> is the background velocity field, and
<span class="math notranslate nohighlight">\(\Omega=[0, 1]^2\)</span> is the spatial domain of interest with boundary
<span class="math notranslate nohighlight">\(\partial\Omega\)</span>.</p>
<p>The background velocity field <span class="math notranslate nohighlight">\(\mathbf{u}(x, y, t)\)</span> is chosen to be periodic in
time, and is given by</p>
<div class="math notranslate nohighlight">
\[\mathbf{u}(x, y, t) := \left(2\sin^2(\pi x)\sin(2\pi y), -\sin(2\pi x)\sin^2(\pi y) \right) \cos(2\pi t/T),\]</div>
<p>where <span class="math notranslate nohighlight">\(T\)</span> is the period. At each timestep of the simulation we will update this
field so we define a function that will return its vector expression.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">T</span> <span class="o">=</span> <span class="mf">6.0</span>


<span class="k">def</span> <span class="nf">velocity_expression</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">u_expr</span> <span class="o">=</span> <span class="n">as_vector</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">t</span> <span class="o">/</span> <span class="n">T</span><span class="p">),</span>
            <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">t</span> <span class="o">/</span> <span class="n">T</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">u_expr</span>
</pre></div>
</div>
<p>We proceed similarly with prescribing initial conditions. At <span class="math notranslate nohighlight">\(t=0\)</span>, we
initialise the tracer concentration <span class="math notranslate nohighlight">\(c_0 = c(x, y, 0)\)</span> to be <span class="math notranslate nohighlight">\(1\)</span> inside
a circular region of radius <span class="math notranslate nohighlight">\(r_0=0.15\)</span> centred at <span class="math notranslate nohighlight">\((x_0, y_0)=(0.5, 0.65)\)</span>
and <span class="math notranslate nohighlight">\(0\)</span> elsewhere in the domain. Note that such a discontinuous function will
not be represented well on a coarse uniform mesh.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_initial_condition</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">ball_r</span><span class="p">,</span> <span class="n">ball_x0</span><span class="p">,</span> <span class="n">ball_y0</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.65</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">ball_x0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ball_y0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">c0</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">conditional</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">ball_r</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">c0</span>
</pre></div>
</div>
<p>Now we are ready to solve the advection problem. Since we will solve the problem
several times, we will wrap up the code in a function that we can easily call
for each subinterval. The function takes the mesh over which to solve the problem,
time interval <span class="math notranslate nohighlight">\([t_{\text{start}}, t_{\text{end}}]\)</span> over which to solve it, and
the initial condition <span class="math notranslate nohighlight">\(c_0 = c(x, y, t_{\text{start}})\)</span>. The function returns
the solution <span class="math notranslate nohighlight">\(c(x, y, t_{\text{end}})\)</span>.</p>
<p>Note that we include streamline upwind Petrov Galerkin (SUPG) stabilisation in
the test function in order to ensure numerical stability.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_simulation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">c0</span><span class="p">):</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">c_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span>  <span class="c1"># project initial condition onto the current mesh</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>  <span class="c1"># solution at current timestep</span>

    <span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">velocity_expression</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t_start</span><span class="p">))</span>  <span class="c1"># vel. at t_start</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>  <span class="c1"># velocity field at current timestep</span>

    <span class="c1"># SUPG stabilisation</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># diffusivity coefficient</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">CellSize</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>  <span class="c1"># mesh cell size</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>  <span class="c1"># velocity magnitude</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">U</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">min_value</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">U</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">D</span><span class="p">))</span>

    <span class="c1"># Apply SUPG stabilisation to the test function</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">+=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

    <span class="c1"># Time-stepping parameters</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># timestep size</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># Crank-Nicolson implicitness</span>

    <span class="c1"># Variational form of the advection equation</span>
    <span class="n">trial</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">trial</span><span class="p">)),</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">c_</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u_</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">c_</span><span class="p">)),</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>

    <span class="c1"># Define variational problem</span>
    <span class="n">lvp</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;on_boundary&quot;</span><span class="p">))</span>
    <span class="n">lvs</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">lvp</span><span class="p">)</span>

    <span class="c1"># Integrate from t_start to t_end</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_start</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_end</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
        <span class="c1"># Update the background velocity field at the current timestep</span>
        <span class="n">u</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">velocity_expression</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>

        <span class="c1"># Solve the advection equation</span>
        <span class="n">lvs</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="c1"># Update the solution at the previous timestep</span>
        <span class="n">c_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">u_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c</span>
</pre></div>
</div>
<p>Finally, we are ready to run the simulation. We will first solve the entire
problem over two uniform meshes: one with 32 elements in each direction and another
with 128 elements in each direction. Since the flow reverts to its initial state at
time <span class="math notranslate nohighlight">\(t=T/2\)</span>, we run the simulations over the interval <span class="math notranslate nohighlight">\([0, T/2]\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulation_end_time</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="mf">2.0</span>

<span class="n">mesh_coarse</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">c0_coarse</span> <span class="o">=</span> <span class="n">get_initial_condition</span><span class="p">(</span><span class="n">mesh_coarse</span><span class="p">)</span>
<span class="n">c_coarse_final</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="n">mesh_coarse</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">simulation_end_time</span><span class="p">,</span> <span class="n">c0_coarse</span><span class="p">)</span>

<span class="n">mesh_fine</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
<span class="n">c0_fine</span> <span class="o">=</span> <span class="n">get_initial_condition</span><span class="p">(</span><span class="n">mesh_fine</span><span class="p">)</span>
<span class="n">c_fine_final</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="n">mesh_fine</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">simulation_end_time</span><span class="p">,</span> <span class="n">c0_fine</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now compare computed final concentration fields on the two meshes to the
initial condition.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">firedrake.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">time_labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s2">&quot;$t=0$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$t=T/2$&quot;</span><span class="p">]</span>
<span class="n">c_values</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c0_coarse</span><span class="p">,</span> <span class="n">c0_fine</span><span class="p">],</span> <span class="p">[</span><span class="n">c_coarse_final</span><span class="p">,</span> <span class="n">c_fine_final</span><span class="p">]]</span>
<span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_coarse</span><span class="p">,</span> <span class="n">mesh_fine</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">mesh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c_values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">meshes</span><span class="p">):</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">tripcolor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span><span class="si">}</span><span class="s2"> mesh vertices&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">time_labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;bubble_shear-uniform.jpg&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" style="width: 80%">
<img alt="../_images/bubble_shear-uniform.jpg" src="../_images/bubble_shear-uniform.jpg" />
</figure>
<p>We observe that the concentration fields have not returned to their initial value
at the end of the simulation, as we would have expected. This is particularly obvious
in the coarse resolution simulation. This is due to the addition of the SUPG
stabilisation to the weak form of the advection equation, which adds numerical
diffusion. Numerical diffusion is necessary for numerical stability and for preventing
oscillations, but it also makes the solution irreversible. The amount of difussion
added is related to the grid Péclet number <span class="math notranslate nohighlight">\(Pe = U\,h/2D\)</span>: the coarser the mesh
is, the more diffusion is added.</p>
<p>In order to quantify the above observation, we will compute the relative <span class="math notranslate nohighlight">\(L^2\)</span>
error between the initial condition and the final concentration field on the final
mesh.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_rel_error</span><span class="p">(</span><span class="n">c_init</span><span class="p">,</span> <span class="n">c_final</span><span class="p">):</span>
    <span class="n">init_l2_norm</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">c_init</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s2">&quot;L2&quot;</span><span class="p">)</span>
    <span class="n">abs_l2_error</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">c_init</span><span class="p">,</span> <span class="n">c_final</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s2">&quot;L2&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">abs_l2_error</span> <span class="o">/</span> <span class="n">init_l2_norm</span>


<span class="n">coarse_error</span> <span class="o">=</span> <span class="n">compute_rel_error</span><span class="p">(</span><span class="n">c0_coarse</span><span class="p">,</span> <span class="n">c_coarse_final</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Relative L2 error on the coarse mesh: </span><span class="si">{</span><span class="n">coarse_error</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
<span class="n">fine_error</span> <span class="o">=</span> <span class="n">compute_rel_error</span><span class="p">(</span><span class="n">c0_fine</span><span class="p">,</span> <span class="n">c_fine_final</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Relative L2 error on the fine mesh: </span><span class="si">{</span><span class="n">fine_error</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Relative L2 error on the coarse mesh: 56.52%</span>
<span class="go">Relative L2 error on the fine mesh: 32.29%</span>
</pre></div>
</div>
<p>Since accurate simulations require very fine resolution, which may be computationally
too prohitibive, we will now demonstrate how to use mesh adaptation techniques to
refine the mesh only in regions and at times where that is necessary.
For the purposes of this demo, we are going to adapt the mesh 15 times throughout the
simulation, at equal time intervals (i.e., every 0.2s of simulation time).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_adaptations</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">interval_length</span> <span class="o">=</span> <span class="n">simulation_end_time</span> <span class="o">/</span> <span class="n">num_adaptations</span>
</pre></div>
</div>
<p>We will also define a function that will allow us to easily plot the adapted mesh, as
well as the solution fields at the beginning and end of each subinterval.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">triplot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">tripcolor</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">tripcolor</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span><span class="si">}</span><span class="s2"> vertices)&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solution at t=</span><span class="si">{</span><span class="n">i</span><span class="o">*</span><span class="n">interval_length</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solution at t=</span><span class="si">{</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">interval_length</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">axes</span> <span class="ow">in</span> <span class="n">ax</span><span class="p">:</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bubble_shear-</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.jpg&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
<p>As mentioned in the introduction, we shall demonstrate two different mesh adaptation
strategies. Let us begin with the classical mesh adaptation algorithm, which adapts
each mesh before solving the advection equation over the corresponding subinterval.
Here we will use the <a class="reference internal" href="../animate.html#animate.metric.RiemannianMetric" title="animate.metric.RiemannianMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">RiemannianMetric</span></code></a> class to define the metric, which we
will compute based on the Hessian of the concentration field. Let us therefore define
a function which takes the original mesh and the concentration field as arguments, and
returns the adapted mesh. We will also define parameters for computing the metric.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">animate.adapt</span> <span class="kn">import</span> <span class="n">adapt</span>
<span class="kn">from</span> <span class="nn">animate.metric</span> <span class="kn">import</span> <span class="n">RiemannianMetric</span>

<span class="n">metric_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;dm_plex_metric&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;target_complexity&quot;</span><span class="p">:</span> <span class="mf">1500.0</span><span class="p">,</span>
        <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span>  <span class="c1"># normalisation order</span>
        <span class="s2">&quot;h_min&quot;</span><span class="p">:</span> <span class="mf">1e-04</span><span class="p">,</span>  <span class="c1"># minimum allowed edge length</span>
        <span class="s2">&quot;h_max&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># maximum allowed edge length</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">adapt_classical</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">P1_ten</span> <span class="o">=</span> <span class="n">TensorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="n">RiemannianMetric</span><span class="p">(</span><span class="n">P1_ten</span><span class="p">)</span>
    <span class="n">metric</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">metric_params</span><span class="p">)</span>
    <span class="n">metric</span><span class="o">.</span><span class="n">compute_hessian</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">metric</span><span class="o">.</span><span class="n">normalise</span><span class="p">()</span>
    <span class="n">adapted_mesh</span> <span class="o">=</span> <span class="n">adapt</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">adapted_mesh</span>
</pre></div>
</div>
<p>We can now run the simulation, but we adapt the mesh before each subinterval. We begin
with a coarse uniform mesh and track the number of vertices of each adapted mesh.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">mesh_numVertices</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">get_initial_condition</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_adaptations</span><span class="p">):</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_length</span>  <span class="c1"># subinterval start time</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_length</span>  <span class="c1"># subinterval end time</span>

    <span class="c1"># Adapt the mesh based on the concentration field at t0</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">adapt_classical</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">mesh_numVertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">())</span>

    <span class="c1"># Make a copy of the initial condition for plotting purposes</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Solve the advection equation over the subinterval (t0, t1]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="c1"># Plot the adapted mesh and the concentration field at t0 and t1</span>
    <span class="n">plot_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;classical&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let us examine the final adapted mesh and final concentration field computed on it.
We will also compute the relative <span class="math notranslate nohighlight">\(L^2\)</span> error.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Redefine the initial condition on the final adapted mesh</span>
<span class="n">c0</span> <span class="o">=</span> <span class="n">get_initial_condition</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">classical_c0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span>
<span class="n">classical_error</span> <span class="o">=</span> <span class="n">compute_rel_error</span><span class="p">(</span><span class="n">classical_c0</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Classical mesh adaptation.</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;   Avg. number of vertices: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">mesh_numVertices</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;   Relative L2 error: </span><span class="si">{</span><span class="n">classical_error</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Classical mesh adaptation.</span>
<span class="go">   Avg. number of vertices: 2302.3</span>
<span class="go">   Relative L2 error: 31.76%</span>
</pre></div>
</div>
<figure class="align-center" style="width: 80%">
<img alt="../_images/bubble_shear-classical_14.jpg" src="../_images/bubble_shear-classical_14.jpg" />
</figure>
<p>As we can see, the relative <span class="math notranslate nohighlight">\(L^2\)</span> error is lower than the one obtained with the
uniform fine mesh, even though the average number of vertices is more than 8 times
smaller. This demonstrates the effectiveness of mesh adaptation, which we can also
observe in the figure above. We see that final mesh has clearly been refined around
the bubble at the beginning of the final subinterval and coarsened elsewhere.</p>
<p>However, we also observe that the bubble has advected out of the fine resolution
region by the end of the subinterval. This is a common occurence in time-dependent
mesh adaptation, known as the <em>lagging mesh</em> problem, where the mesh is said to lag
with respect to the solution.
Ensuring that the bubble remains well-resolved throughout the simulation
is not a trivial task, as it requires predicting where the bubble will be in the
future. Earliest attempts at preventing the lagging mesh problem introduced a safety
margin around the fine-resolution region. While potentially very effective, depending
on the size of the margin, this approach is also likely to be inefficient as it may
prescribe fine resolution in regions where it is not needed.</p>
<p>For advection-dominated problems, as is the case here, a <em>metric advection</em> algorithm
has been proposed in <span id="id2">[]</span>. The idea is to still compute the metric
based on the solution at the current time, but then to advect the metric along the
flow in order to predict where to prescribe fine resolution in the future. By
combining the advected metrics in time, we obtain a final metric that is
representative of the evolving solution throughout the subinterval. We achieve this in
the following function, where we solve the before-seen advection equation for each
component of the metric tensor.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">adapt_metric_advection</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">P1_ten</span> <span class="o">=</span> <span class="n">TensorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">RiemannianMetric</span><span class="p">(</span><span class="n">P1_ten</span><span class="p">)</span>  <span class="c1"># metric at current timestep</span>
    <span class="n">m_</span> <span class="o">=</span> <span class="n">RiemannianMetric</span><span class="p">(</span><span class="n">P1_ten</span><span class="p">)</span>  <span class="c1"># metric at previous timestep</span>
    <span class="n">metric_intersect</span> <span class="o">=</span> <span class="n">RiemannianMetric</span><span class="p">(</span><span class="n">P1_ten</span><span class="p">)</span>

    <span class="c1"># Compute the Hessian metric at t_start</span>
    <span class="k">for</span> <span class="n">mtrc</span> <span class="ow">in</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">m_</span><span class="p">,</span> <span class="n">metric_intersect</span><span class="p">]:</span>
        <span class="n">mtrc</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">metric_params</span><span class="p">)</span>
    <span class="n">m_</span><span class="o">.</span><span class="n">compute_hessian</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">m_</span><span class="o">.</span><span class="n">enforce_spd</span><span class="p">(</span><span class="n">restrict_sizes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">restrict_anisotropy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Set the boundary condition for the metric tensor</span>
    <span class="n">h_bc</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">P1_ten</span><span class="p">)</span>
    <span class="n">h_max</span> <span class="o">=</span> <span class="n">metric_params</span><span class="p">[</span><span class="s2">&quot;dm_plex_metric&quot;</span><span class="p">][</span><span class="s2">&quot;h_max&quot;</span><span class="p">]</span>
    <span class="n">h_bc</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Constant</span><span class="p">([[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">h_max</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">h_max</span><span class="o">**</span><span class="mi">2</span><span class="p">]]))</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">velocity_expression</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t_start</span><span class="p">))</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># timestep size</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># Crank-Nicolson implicitness</span>

    <span class="c1"># SUPG stabilisation</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">CellSize</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">U</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">min_value</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">U</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">D</span><span class="p">))</span>

    <span class="c1"># Apply SUPG stabilisation</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">P1_ten</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">+=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

    <span class="c1"># Variational form of the advection equation for the metric tensor</span>
    <span class="n">trial</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">P1_ten</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">trial</span><span class="p">)),</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">m_</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u_</span><span class="p">,</span> <span class="n">grad</span><span class="p">(</span><span class="n">m_</span><span class="p">)),</span> <span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">bcs</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">P1_ten</span><span class="p">,</span> <span class="n">h_bc</span><span class="p">,</span> <span class="s2">&quot;on_boundary&quot;</span><span class="p">)</span>
    <span class="n">lvp</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs</span><span class="p">)</span>
    <span class="n">lvs</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">lvp</span><span class="p">)</span>

    <span class="c1"># Integrate from t_start to t_end</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_start</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_end</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
        <span class="n">u</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">velocity_expression</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>

        <span class="n">lvs</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="c1"># Intersect metrics at every timestep</span>
        <span class="n">m</span><span class="o">.</span><span class="n">enforce_spd</span><span class="p">(</span><span class="n">restrict_sizes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">restrict_anisotropy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">metric_intersect</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># Update fields at the previous timestep</span>
        <span class="n">m_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">u_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

    <span class="n">metric_intersect</span><span class="o">.</span><span class="n">normalise</span><span class="p">()</span>
    <span class="n">amesh</span> <span class="o">=</span> <span class="n">adapt</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">metric_intersect</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">amesh</span>
</pre></div>
</div>
<p>We can now run the simulation over the entire time interval, but now we will adapt the
mesh at the beginning of each subinterval using the metric advection algorithm.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">mesh_numVertices</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">get_initial_condition</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_adaptations</span><span class="p">):</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">interval_length</span>  <span class="c1"># subinterval start time</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval_length</span>  <span class="c1"># subinterval end time</span>

    <span class="c1"># Adapt the mesh based on the concentration field at t0</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">adapt_metric_advection</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">mesh_numVertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">())</span>

    <span class="n">c0</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Solve the advection equation over the subinterval (t0, t1]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="n">plot_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;metric_advection&quot;</span><span class="p">)</span>

<span class="n">c0</span> <span class="o">=</span> <span class="n">get_initial_condition</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">metric_adv_c0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span>
<span class="n">metric_adv_error</span> <span class="o">=</span> <span class="n">compute_rel_error</span><span class="p">(</span><span class="n">metric_adv_c0</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Metric advection mesh adaptation.</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;   Avg. number of vertices: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">mesh_numVertices</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;   Relative L2 error: </span><span class="si">{</span><span class="n">metric_adv_error</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Metric advection mesh adaptation.</span>
<span class="go">   Avg. number of vertices: 2032.7</span>
<span class="go">   Relative L2 error: 31.30%</span>
</pre></div>
</div>
<figure class="align-center" style="width: 80%">
<img alt="../_images/bubble_shear-metric_advection_14.jpg" src="../_images/bubble_shear-metric_advection_14.jpg" />
</figure>
<p>The relative <span class="math notranslate nohighlight">\(L^2\)</span> error of 31.30% is slightly lower than the one obtained with
the classical mesh adaptation algorithm, but note that the average number of vertices
is about 15% smaller. Looking into the final adapted mesh and concentration fields in
the above figure, we now observe that the mesh is indeed refined in a much wider
region - ensuring that the bubble remains well-resolved throughout the subinterval.
However, this also means that the available resolution is more widely distributed,
leading to a coarser local resolution compared to classical mesh adaptation.</p>
<p>Let us now consider the implications and limitations of each approach. Firstly,
given a high enough adaptation frequency (i.e. number of adaptations/subintervals),
the lagging mesh problem can be mitigated with the classical mesh adaptation
algorithm. This may end up being more computationally efficient than the metric
advection algorithm, which requires solving the advection equation once more
at each timestep, as well as potentially expensive metric computations.
However, while increasing the mesh adaptation frequency would alleviate the mesh lag,
doing so may introduce large errors due to frequent solution transfers between meshes.</p>
<p>This is where the advantage of the metric advection algorithm lies: it predicts where
to prescribe fine resolution in the future, and thus avoids the need for frequent
solution transfers. We can assure ourselves of that by repeating the above simulations
with <code class="docutils literal notranslate"><span class="pre">num_adaptations</span> <span class="pre">=</span> <span class="pre">5</span></code>, which yields relative errors of 61.06% and 36.86%
for the classical and metric advection algorithms, respectively. Conversely,
increasing the adaptation frequency to <code class="docutils literal notranslate"><span class="pre">num_adaptations</span> <span class="pre">=</span> <span class="pre">50</span></code> yields again relative
errors closer to one another. Note that the algorithms are identical if we adapt at
every timestep. We summarise these results in the table below, noting also the average
number of vertices, <span class="math notranslate nohighlight">\(N_v\)</span>.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Number of adaptations</p></th>
<th class="head"><p>Classical (avg. <span class="math notranslate nohighlight">\(N_v\)</span>)</p></th>
<th class="head"><p>Metric advection (avg. <span class="math notranslate nohighlight">\(N_v\)</span>)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>5</p></td>
<td><p>61.06% (2200.2)</p></td>
<td><p>36.86% (1922.2)</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>31.76% (2302.3)</p></td>
<td><p>31.30% (2032.7)</p></td>
</tr>
<tr class="row-even"><td><p>50</p></td>
<td><p>26.80% (2522.1)</p></td>
<td><p>27.99% (2166.3)</p></td>
</tr>
</tbody>
</table>
<p>Furthermore, the problem considered in this example is relatively well-suited for
classical mesh adaptation, as the bubble concentration field reverses and therefore
often indeed remains in the finely-resolved region. We can observe that in the below
figure, at the subinterval <span class="math notranslate nohighlight">\((1.4 s, 1.6 s]\)</span>. This also means that the meshes
adapted using classical and metric advection algorithms are qualitatively similar at
this subinterval.</p>
<figure class="align-center" style="width: 80%">
<img alt="../_images/bubble_shear-classical_7.jpg" src="../_images/bubble_shear-classical_7.jpg" />
</figure>
<p>In conclusion, the choice of mesh adaptation algorithm depends on the specific problem
at hand, as well as the computational resources available.</p>
<p class="rubric">Exercise</p>
<p>Repeat above experiments and investigate each of the adapted meshes. At what
subintervals do the two algorithms produce most similar and most different meshes?
Experiment with different metric parameters, different adaptation frequencies, and
even different velocity fields to further explore the capabilities and limitations of
the algorithms presented above.</p>
<p>This demo can also be accessed as a <a class="reference external" href="bubble_shear.py">Python script</a>.</p>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/demos/bubble_shear.py.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Animate, Movement, Goalie and UM2N 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">On-the-fly time-dependent mesh adaptation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021-2024, Joseph G. Wallwork et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    </div>
  </body>
</html>