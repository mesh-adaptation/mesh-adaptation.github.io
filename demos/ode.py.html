<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Solving ordinary differential equations using Goalie &#8212; Animate, Movement and Goalie 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <script src="../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Animate, Movement and Goalie 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solving ordinary differential equations using Goalie</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="solving-ordinary-differential-equations-using-goalie">
<h1>Solving ordinary differential equations using Goalie<a class="headerlink" href="#solving-ordinary-differential-equations-using-goalie" title="Link to this heading">¶</a></h1>
<p>Goalie was designed primarily with partial differential equations (PDEs) in mind.
However, it can also be used to solve ordinary differential equations (ODEs).</p>
<p>For example, consider the scalar, linear ODE,</p>
<div class="math notranslate nohighlight">
\[\frac{\mathrm{d}u}{\mathrm{d}t} = u,\quad u(0) = 1,\]</div>
<p>which we solve for <span class="math notranslate nohighlight">\(u(t)\)</span> over the time period <span class="math notranslate nohighlight">\(t\in(0,1]\)</span>. It is
straightforward to verify that this ODE has analytical solution</p>
<div class="math notranslate nohighlight">
\[u(t) = e^t.\]</div>
<p>Given a sample of points in time, we can plot this as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.01</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="s2">&quot;--x&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Analytical solution&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Time, $t$&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$u$&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;ode-analytical.jpg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" style="width: 70%">
<img alt="../_images/ode-analytical.jpg" src="../_images/ode-analytical.jpg" />
</figure>
<p>In this demo, we solve the above ODE numerically using three different timestepping
schemes and compare the results.</p>
<p>First, import from the namespaces of Firedrake and Goalie.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">goalie</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Next, create a simple <a class="reference internal" href="../goalie.html#goalie.time_partition.TimeInterval" title="goalie.time_partition.TimeInterval"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeInterval</span></code></a> object to hold information related to
the time discretisation. This is a simplified version of <a class="reference internal" href="../goalie.html#goalie.time_partition.TimePartition" title="goalie.time_partition.TimePartition"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimePartition</span></code></a>,
which only has one subinterval.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">end_time</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">time_partition</span> <span class="o">=</span> <span class="n">TimeInterval</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Much of the following might seem excessive for this example. However, it exists to
allow for the flexibility required in later PDE examples.</p>
<p>We need to create a <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionSpace</span></code> for the solution field to live in. Given
that we have a scalar ODE, the solution is just a real number at each time level. We
represent this using the degree-0 <span class="math notranslate nohighlight">\(R\)</span>-space, as follows. A mesh is required to
define a function space in Firedrake, although what the mesh is doesn’t actually
matter for this example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_function_spaces</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
</pre></div>
</div>
<p>Next, we need to supply the initial condition <span class="math notranslate nohighlight">\(u(0) = 1\)</span>. We do this by creating
a <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code> in the <span class="math notranslate nohighlight">\(R\)</span>-space and assigning it the value 1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_initial_condition</span><span class="p">(</span><span class="n">point_seq</span><span class="p">):</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="n">Function</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)}</span>
</pre></div>
</div>
<p>The first timestepping scheme we consider is Forward Euler, which is also known as
Explicit Euler because it approximates the solution at time level <span class="math notranslate nohighlight">\(i+1\)</span> as an
explicit function of solution approximation at time level <span class="math notranslate nohighlight">\(i\)</span>.</p>
<div class="math notranslate nohighlight">
\[\frac{u_{i+1} - u_i}{\Delta t} = u_i,\]</div>
<p>where <span class="math notranslate nohighlight">\(u_k\)</span> denotes the approximation at time level <cite>k</cite> and <span class="math notranslate nohighlight">\(\Delta k\)</span> is
the timestep length. This expression may be rearranged as</p>
<div class="math notranslate nohighlight">
\[u_{i+1} - u_i - \Delta t u_i = 0.\]</div>
<p>Even though there are no spatial derivatives in our problem, we still have to
represent the problem in a finite element formulation in order to solve it using
Goalie. Recall that functions in our function space, <span class="math notranslate nohighlight">\(R\)</span> are just scalar valued.
To use the finite element notation, we multiply both sides of the equation by a test
function and integrate:</p>
<div class="math notranslate nohighlight">
\[\int_0^1 (u_{i+1} - u_i  - \Delta t u_i) v \mathrm{d}t = 0, \forall v\in R.\]</div>
<p>It’s worth noting that integration over an <span class="math notranslate nohighlight">\(R\)</span>-space amounts to summation and
because we have a scalar <span class="math notranslate nohighlight">\(R\)</span>-space it is a summation of a single value. Again,
this machinery may seem excessive but it becomes necessary for PDE problems.</p>
<p>The Forward Euler scheme may be implemented as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_form_forward_euler</span><span class="p">(</span><span class="n">point_seq</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">form</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">solutions</span><span class="p">):</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">u_</span> <span class="o">=</span> <span class="n">solutions</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">point_seq</span><span class="o">.</span><span class="n">time_partition</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># Setup variational problem</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">u_</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="n">F</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">form</span>
</pre></div>
</div>
<p>We have a method defining the Forward Euler scheme. To put it into practice, we need
to define the solver. This boils down to applying the update repeatedly in a time
loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_solver</span><span class="p">(</span><span class="n">point_seq</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">ic</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">time_partition</span>

        <span class="c1"># Define Function to hold the approximation</span>
        <span class="n">function_space</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>

        <span class="c1"># Initialise &#39;lagged&#39; solution</span>
        <span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">function_space</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;u_old&quot;</span><span class="p">)</span>
        <span class="n">u_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">ic</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">])</span>

        <span class="c1"># Define the (trivial) form</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">form</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_</span><span class="p">)})[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span>

        <span class="c1"># Since the form is trivial, we can solve with a single application of a Jacobi</span>
        <span class="c1"># preconditioner</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;jacobi&quot;</span><span class="p">}</span>

        <span class="c1"># Time integrate from t_start to t_end</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">subintervals</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t_start</span>
        <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_end</span> <span class="o">-</span> <span class="mf">1.0e-05</span><span class="p">:</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ad_block_tag</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>
            <span class="n">u_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="n">u</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">solver</span>
</pre></div>
</div>
<p>For this ODE problem, the main driver object is a <a class="reference internal" href="../goalie.html#goalie.point_seq.PointSeq" title="goalie.point_seq.PointSeq"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointSeq</span></code></a>, which is
defined in terms of the <a class="reference internal" href="../goalie.html#goalie.time_partition.TimePartition" title="goalie.time_partition.TimePartition"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimePartition</span></code></a> describing the time discretisation,
plus the functions defined above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">point_seq</span> <span class="o">=</span> <span class="n">PointSeq</span><span class="p">(</span>
    <span class="n">time_partition</span><span class="p">,</span>
    <span class="n">get_function_spaces</span><span class="o">=</span><span class="n">get_function_spaces</span><span class="p">,</span>
    <span class="n">get_initial_condition</span><span class="o">=</span><span class="n">get_initial_condition</span><span class="p">,</span>
    <span class="n">get_form</span><span class="o">=</span><span class="n">get_form_forward_euler</span><span class="p">,</span>
    <span class="n">get_solver</span><span class="o">=</span><span class="n">get_solver</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We can solve the ODE using the <a class="reference internal" href="../goalie.html#goalie.mesh_seq.MeshSeq.solve_forward" title="goalie.mesh_seq.MeshSeq.solve_forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_forward()</span></code></a> method and extract the
solution trajectory as follows. The method returns a nested dictionary of solutions,
with the first key specifying the field name and the second key specifying the type of
solution field. For the purposes of this demo, we have field <code class="docutils literal notranslate"><span class="pre">&quot;u&quot;</span></code>, which is a
forward solution. The resulting solution trajectory is a list.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">solutions</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">solve_forward</span><span class="p">()[</span><span class="s2">&quot;u&quot;</span><span class="p">][</span><span class="s2">&quot;forward&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that the solution trajectory does not include the initial value, so we prepend it.
We also convert the solution <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code>s to <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>s, for plotting
purposes. Whilst there is only one subinterval in this example, we show how to loop
over subintervals, as this is instructive for the general case.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">forward_euler_trajectory</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">forward_euler_trajectory</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="nb">float</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="k">for</span> <span class="n">subinterval</span> <span class="ow">in</span> <span class="n">solutions</span> <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">subinterval</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Plot the trajectory and compare it against the analytical solution.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="s2">&quot;--x&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Analytical solution&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">forward_euler_trajectory</span><span class="p">,</span> <span class="s2">&quot;--+&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Forward Euler&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Time, $t$&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$u$&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;ode-forward_euler.jpg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" style="width: 70%">
<img alt="../_images/ode-forward_euler.jpg" src="../_images/ode-forward_euler.jpg" />
</figure>
<p>The Forward Euler approximation to the analytical solution isn’t terrible, but clearly
consistently underestimates. Now let’s try using Backward Euler, also known as
Implicit Euler because the approximation at the next time level is represented as an
implicit function of the approximation at the current time level:</p>
<div class="math notranslate nohighlight">
\[\frac{u_{i+1} - u_i}{\Delta t} = u_{i+1}.\]</div>
<p>Similarly to the above, this gives rise to</p>
<div class="math notranslate nohighlight">
\[\int_0^1 (u_{i+1} - u_{i} - \Delta t u_{i+1}) v \mathrm{d}t, \forall v\in R.\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_form_backward_euler</span><span class="p">(</span><span class="n">point_seq</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">form</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">solutions</span><span class="p">):</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">u_</span> <span class="o">=</span> <span class="n">solutions</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">point_seq</span><span class="o">.</span><span class="n">time_partition</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># Setup variational problem</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_</span> <span class="o">-</span> <span class="n">u</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="n">F</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">form</span>
</pre></div>
</div>
<p>To apply Backward Euler we create the <a class="reference internal" href="../goalie.html#goalie.point_seq.PointSeq" title="goalie.point_seq.PointSeq"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointSeq</span></code></a> in the same way, just with
<cite>get_form_forward_euler</cite> substituted for <cite>get_form_backward_euler</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">point_seq</span> <span class="o">=</span> <span class="n">PointSeq</span><span class="p">(</span>
    <span class="n">time_partition</span><span class="p">,</span>
    <span class="n">get_function_spaces</span><span class="o">=</span><span class="n">get_function_spaces</span><span class="p">,</span>
    <span class="n">get_initial_condition</span><span class="o">=</span><span class="n">get_initial_condition</span><span class="p">,</span>
    <span class="n">get_form</span><span class="o">=</span><span class="n">get_form_backward_euler</span><span class="p">,</span>
    <span class="n">get_solver</span><span class="o">=</span><span class="n">get_solver</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">solutions</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">solve_forward</span><span class="p">()[</span><span class="s2">&quot;u&quot;</span><span class="p">][</span><span class="s2">&quot;forward&quot;</span><span class="p">]</span>

<span class="n">backward_euler_trajectory</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">backward_euler_trajectory</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="nb">float</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="k">for</span> <span class="n">subinterval</span> <span class="ow">in</span> <span class="n">solutions</span> <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">subinterval</span>
<span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="s2">&quot;--x&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Analytical solution&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">forward_euler_trajectory</span><span class="p">,</span> <span class="s2">&quot;--+&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Forward Euler&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">backward_euler_trajectory</span><span class="p">,</span> <span class="s2">&quot;--o&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Backward Euler&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Time, $t$&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$u$&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;ode-backward_euler.jpg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" style="width: 70%">
<img alt="../_images/ode-backward_euler.jpg" src="../_images/ode-backward_euler.jpg" />
</figure>
<p>This time we see that Implicit Euler consistenly overestimates the solution. Both of
the methods we’ve considered so far are first order methods. To get a better result,
we combine them to obtain the second order Crank-Nicolson method:</p>
<div class="math notranslate nohighlight">
\[\frac{u_{i+1} - u_i}{\Delta t} = (\theta u_{i+1} + (1-\theta) u_i),\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta\in(0,1)\)</span>. The standard choice is to take <span class="math notranslate nohighlight">\(\theta=\frac12\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_form_crank_nicolson</span><span class="p">(</span><span class="n">point_seq</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">form</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">solutions</span><span class="p">):</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">u_</span> <span class="o">=</span> <span class="n">solutions</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">point_seq</span><span class="o">.</span><span class="n">time_partition</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Setup variational problem</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">theta</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_</span><span class="p">))</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="n">F</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">form</span>


<span class="n">point_seq</span> <span class="o">=</span> <span class="n">PointSeq</span><span class="p">(</span>
    <span class="n">time_partition</span><span class="p">,</span>
    <span class="n">get_function_spaces</span><span class="o">=</span><span class="n">get_function_spaces</span><span class="p">,</span>
    <span class="n">get_initial_condition</span><span class="o">=</span><span class="n">get_initial_condition</span><span class="p">,</span>
    <span class="n">get_form</span><span class="o">=</span><span class="n">get_form_crank_nicolson</span><span class="p">,</span>
    <span class="n">get_solver</span><span class="o">=</span><span class="n">get_solver</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">solutions</span> <span class="o">=</span> <span class="n">point_seq</span><span class="o">.</span><span class="n">solve_forward</span><span class="p">()[</span><span class="s2">&quot;u&quot;</span><span class="p">][</span><span class="s2">&quot;forward&quot;</span><span class="p">]</span>
<span class="n">crank_nicolson_trajectory</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">crank_nicolson_trajectory</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="nb">float</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="k">for</span> <span class="n">subinterval</span> <span class="ow">in</span> <span class="n">solutions</span> <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">subinterval</span>
<span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="s2">&quot;--x&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Analytical solution&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">forward_euler_trajectory</span><span class="p">,</span> <span class="s2">&quot;--+&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Forward Euler&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">backward_euler_trajectory</span><span class="p">,</span> <span class="s2">&quot;--o&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Backward Euler&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">crank_nicolson_trajectory</span><span class="p">,</span> <span class="s2">&quot;--*&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Crank-Nicolson&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Time, $t$&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$u$&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;ode-crank_nicolson.jpg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" style="width: 70%">
<img alt="../_images/ode-crank_nicolson.jpg" src="../_images/ode-crank_nicolson.jpg" />
</figure>
<p>With this method, we see that the approximation is of much higher quality. Another
way to see this is to compare the approximations of <span class="math notranslate nohighlight">\(e\)</span> given by each
approach:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;e to 9 d.p.:    </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="si">:</span><span class="s2">.9f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward Euler:  </span><span class="si">{</span><span class="n">forward_euler_trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.9f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Backward Euler: </span><span class="si">{</span><span class="n">backward_euler_trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.9f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Crank-Nicolson: </span><span class="si">{</span><span class="n">crank_nicolson_trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.9f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>e to 9 d.p.:    2.718281828
Forward Euler:  2.488320000
Backward Euler: 3.051757812
Crank-Nicolson: 2.727412827
</pre></div>
</div>
<p>In the <a class="reference external" href="./burgers.py.html">next demo</a>, we move on to solve a <em>partial</em> differential
equation (PDE) using a <code class="xref py py-class docutils literal notranslate"><span class="pre">MeshSeq</span></code>.</p>
<p>This demo can also be accessed as a <a class="reference external" href="ode.py">Python script</a>.</p>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/demos/ode.py.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Animate, Movement and Goalie 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solving ordinary differential equations using Goalie</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021-2024, Joseph G. Wallwork et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>