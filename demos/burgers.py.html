
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Adjoint of Burgers equation &#8212; Pyroteus 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Adjoint of Burgers equation on two meshes" href="burgers2.py.html" />
    <link rel="prev" title="Partitioning a time interval" href="time_partition.py.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="burgers2.py.html" title="Adjoint of Burgers equation on two meshes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="time_partition.py.html" title="Partitioning a time interval"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Pyroteus 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Adjoint of Burgers equation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="adjoint-of-burgers-equation">
<h1>Adjoint of Burgers equation<a class="headerlink" href="#adjoint-of-burgers-equation" title="Permalink to this headline">¶</a></h1>
<p>This demo shows how to solve the adjoint of the <cite>Firedrake</cite>
<a class="reference external" href="https://firedrakeproject.org/demos/burgers.py.html">Burgers equation demo</a>
using Pyroteus. There is no mesh adaptation in this demo;
the PDE</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}\frac{\partial\mathbf u}{\partial t}
+ (\mathbf u\cdot\nabla)\mathbf u
- \nu\nabla^2\mathbf u = \boldsymbol0 \quad\text{in}\quad \Omega\\\end{split}\\(\widehat{\mathbf n}\cdot\nabla)\mathbf u
= \boldsymbol0 \quad\text{on}\quad \partial\Omega\end{aligned}\end{align} \]</div>
<p>and its discrete adjoint are solved on a single, uniform mesh
of the unit square, <span class="math notranslate nohighlight">\(\Omega = [0, 1]^2\)</span>. The forward
solution is initialised as a sine wave and is nonlinearly
advected to the right hand side. See the Firedrake demo for
details on the discretisation used.</p>
<p>We always begin by importing Pyroteus. Adjoint mode is used
so that we have access to the discrete adjoint functionality
due to <cite>dolfin-adjoint</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyroteus_adjoint</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>In this problem, we have a single prognostic variable,
<span class="math notranslate nohighlight">\(\mathbf u\)</span>. Its name is recorded in a list of
fields.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;uv_2d&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>First, we specify how to build a <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionSpace</span></code>,
given some mesh. Function spaces are given as a dictionary,
labelled by the prognostic solution field names. The
function spaces will be built upon the meshes contained
inside an <code class="xref py py-class docutils literal notranslate"><span class="pre">AdjointMeshSeq</span></code> object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_function_spaces</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;uv_2d&#39;</span><span class="p">:</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span>
</pre></div>
</div>
<p>Pyroteus requires a solver with four arguments: a dictionary
containing initial conditions for each prognostic solution,
a start time, an end time and a timestep. The following
pattern is used for the QoI, which will be specified later.
The dictionary usage may seem cumbersome when applied to
such a simple problem, but it comes in handy when solving
adjoint problems associated with coupled systems of equations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_solver</span><span class="p">(</span><span class="n">mesh_seq</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="n">function_space</span> <span class="o">=</span> <span class="n">ic</span><span class="p">[</span><span class="s1">&#39;uv_2d&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">dtc</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>

        <span class="c1"># Set initial condition</span>
        <span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">u_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">ic</span><span class="p">[</span><span class="s1">&#39;uv_2d&#39;</span><span class="p">])</span>

        <span class="c1"># Setup variational problem</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">((</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_</span><span class="p">)</span><span class="o">/</span><span class="n">dtc</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
            <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">)),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> \
            <span class="o">+</span> <span class="n">nu</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

        <span class="c1"># Time integrate from t_start to t_end</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t_start</span>
        <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_end</span> <span class="o">-</span> <span class="mf">1.0e-05</span><span class="p">:</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">u_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;uv_2d&#39;</span><span class="p">:</span> <span class="n">u_</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">solver</span>
</pre></div>
</div>
<p>Pyroteus also requires a function for generating an initial
condition from a function space.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_initial_condition</span><span class="p">(</span><span class="n">mesh_seq</span><span class="p">):</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">mesh_seq</span><span class="o">.</span><span class="n">function_spaces</span><span class="p">[</span><span class="s1">&#39;uv_2d&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh_seq</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;uv_2d&#39;</span><span class="p">:</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">as_vector</span><span class="p">([</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">fs</span><span class="p">)}</span>
</pre></div>
</div>
<p>In line with the
<a class="reference external" href="https://nbviewer.jupyter.org/github/firedrakeproject/firedrake/blob/master/docs/notebooks/11-extract-adjoint-solutions.ipynb">firedrake-adjoint demo</a>, we choose the QoI</p>
<div class="math notranslate nohighlight">
\[J(u) = \int_0^1 \mathbf u(1,y,T_{\mathrm{end}})
\cdot \mathbf u(1,y,T_{\mathrm{end}})\;\mathrm dy,\]</div>
<p>which integrates the square of the solution
<span class="math notranslate nohighlight">\(\mathbf u(x,y,t)\)</span> at the final time over the right
hand boundary.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_qoi</span><span class="p">(</span><span class="n">mesh_seq</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">end_time_qoi</span><span class="p">(</span><span class="n">sol</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;uv_2d&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">end_time_qoi</span>
</pre></div>
</div>
<p>Now that we have the above functions defined, we move onto the
concrete parts of the solver, which mimic the original demo.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span>
</pre></div>
</div>
<p>Another requirement to solve the adjoint problem using
Pyroteus is a <code class="docutils literal notranslate"><span class="pre">TimePartition</span></code>. This object captures how the
temporal domain is to be divided for the purposes of mesh
adaptation. In our case, there is a single mesh, so the partition
is trivial.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_subintervals</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">TimePartition</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">num_subintervals</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">timesteps_per_export</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we are able to construct an <code class="xref py py-class docutils literal notranslate"><span class="pre">AdjointMeshSeq</span></code> and
thereby call its <code class="docutils literal notranslate"><span class="pre">solve_adjoint</span></code> method. This computes the QoI
value and returns a dictionary of solutions for the forward and adjoint
problems. The solution dictionary has keys <cite>‘forward’</cite>, <cite>‘forward_old’</cite>,
<cite>‘adjoint’</cite> and <cite>‘adjoint_next’</cite> and arrays as values. When passed
an index corresponding to a particular exported timestep, the array
entries correspond to the current forward solution, the forward
solution at the previous timestep, the current adjoint solution and
the adjoint solution at the next timestep, respectively.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh_seq</span> <span class="o">=</span> <span class="n">AdjointMeshSeq</span><span class="p">(</span>
    <span class="n">P</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">get_function_spaces</span><span class="p">,</span> <span class="n">get_initial_condition</span><span class="p">,</span>
    <span class="n">get_solver</span><span class="p">,</span> <span class="n">get_qoi</span><span class="p">,</span> <span class="n">qoi_type</span><span class="o">=</span><span class="s1">&#39;end_time&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">solutions</span> <span class="o">=</span> <span class="n">mesh_seq</span><span class="o">.</span><span class="n">solve_adjoint</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally, we plot the adjoint solution at each exported timestep by
looping over <code class="docutils literal notranslate"><span class="pre">solutions['adjoint']</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exports_per_subinterval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">cols</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">num_subintervals</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span> <span class="mi">24</span><span class="o">//</span><span class="n">cols</span><span class="p">))</span>
<span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adj_sols_step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">solutions</span><span class="o">.</span><span class="n">uv_2d</span><span class="o">.</span><span class="n">adjoint</span><span class="p">):</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">adj_sol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adj_sols_step</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">tricontourf</span><span class="p">(</span><span class="n">adj_sol</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;t=</span><span class="si">{</span><span class="n">i</span><span class="o">*</span><span class="n">end_time</span><span class="o">/</span><span class="n">cols</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">timesteps_per_export</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">timesteps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span>
        <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;burgers-end_time.jpg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" style="width: 50%">
<img alt="../_images/burgers-end_time.jpg" src="../_images/burgers-end_time.jpg" />
</figure>
<p>Where the arrow of time progresses forwards for Burgers equation,
it reverses for its adjoint. As such, the plots should be read from
bottom to top. The QoI acts as an impulse at the final time, which
propagates in the opposite direction than information flows in the
forward problem.</p>
<p>In the <a class="reference external" href="./burgers2.py.html">next demo</a>, we solve the same problem
on two subintervals and check that the results match.</p>
<p>This demo can also be accessed as a <a class="reference external" href="burgers.py">Python script</a>.</p>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="time_partition.py.html"
                        title="previous chapter">Partitioning a time interval</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="burgers2.py.html"
                        title="next chapter">Adjoint of Burgers equation on two meshes</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/demos/burgers.py.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="burgers2.py.html" title="Adjoint of Burgers equation on two meshes"
             >next</a> |</li>
        <li class="right" >
          <a href="time_partition.py.html" title="Partitioning a time interval"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Pyroteus 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Adjoint of Burgers equation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Joseph G. Wallwork et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>