
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyroteus.kernel &#8212; Pyroteus 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Pyroteus 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyroteus.kernel</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyroteus.kernel</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions which generate C kernels for dense numerical linear algebra.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="n">op2</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">firedrake.slate.slac.compiler</span> <span class="kn">import</span> <span class="n">PETSC_ARCH</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">PETSC_ARCH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;PETSC_DIR&#39;</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;PETSC_ARCH&#39;</span><span class="p">))</span>
<span class="n">include_dir</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/include/eigen3&quot;</span> <span class="o">%</span> <span class="n">PETSC_ARCH</span><span class="p">]</span>


<div class="viewcode-block" id="eigen_kernel"><a class="viewcode-back" href="../../pyroteus.html#pyroteus.kernel.eigen_kernel">[docs]</a><span class="k">def</span> <span class="nf">eigen_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to easily pass Eigen kernels</span>
<span class="sd">    to Firedrake via PyOP2.</span>

<span class="sd">    :arg kernel: a string containing C code which</span>
<span class="sd">        is to be formatted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">op2</span><span class="o">.</span><span class="n">Kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">kernel</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">cpp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_dirs</span><span class="o">=</span><span class="n">include_dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="postproc_metric"><a class="viewcode-back" href="../../pyroteus.html#pyroteus.kernel.postproc_metric">[docs]</a><span class="k">def</span> <span class="nf">postproc_metric</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">a_max</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Post-process a metric field in order to enforce</span>
<span class="sd">    max/min element sizes and anisotropy.</span>

<span class="sd">    :arg d: spatial dimension</span>
<span class="sd">    :arg a_max: maximum element anisotropy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;Eigen/Dense&gt;</span>

<span class="s2">using namespace Eigen;</span>

<span class="s2">void postproc_metric(double A_[</span><span class="si">%d</span><span class="s2">], const double * h_min_, const double * h_max_)</span>
<span class="s2">{</span>

<span class="s2">  // Map input/output metric onto an Eigen object and map h_min/h_max to doubles</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; A((double *)A_);</span>
<span class="s2">  double h_min = *h_min_;</span>
<span class="s2">  double h_max = *h_max_;</span>

<span class="s2">  // Solve eigenvalue problem</span>
<span class="s2">  SelfAdjointEigenSolver&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt;&gt; eigensolver(A);</span>
<span class="s2">  Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; Q = eigensolver.eigenvectors();</span>
<span class="s2">  Vector</span><span class="si">%d</span><span class="s2">d D = eigensolver.eigenvalues();</span>

<span class="s2">  // Scale eigenvalues appropriately</span>
<span class="s2">  int i;</span>
<span class="s2">  double max_eig = 0.0;</span>
<span class="s2">  for (i=0; i&lt;</span><span class="si">%d</span><span class="s2">; i++) {</span>
<span class="s2">    D(i) = fmin(pow(h_min, -2), fmax(pow(h_max, -2), abs(D(i))));</span>
<span class="s2">    max_eig = fmax(max_eig, D(i));</span>
<span class="s2">  }</span>
<span class="s2">  for (i=0; i&lt;</span><span class="si">%d</span><span class="s2">; i++) D(i) = fmax(D(i), pow(</span><span class="si">%f</span><span class="s2">, -2) * max_eig);</span>

<span class="s2">  // Build metric from eigendecomposition</span>
<span class="s2">  A = Q * D.asDiagonal() * Q.transpose();</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a_max</span><span class="p">)</span></div>


<div class="viewcode-block" id="intersect"><a class="viewcode-back" href="../../pyroteus.html#pyroteus.kernel.intersect">[docs]</a><span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intersect two metric fields.</span>

<span class="sd">    :arg d: spatial dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;Eigen/Dense&gt;</span>

<span class="s2">using namespace Eigen;</span>

<span class="s2">void intersect(double M_[</span><span class="si">%d</span><span class="s2">], const double * A_, const double * B_) {</span>

<span class="s2">  // Map inputs and outputs onto Eigen objects</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; M((double *)M_);</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; A((double *)A_);</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; B((double *)B_);</span>

<span class="s2">  // Solve eigenvalue problem of first metric, taking square root of eigenvalues</span>
<span class="s2">  SelfAdjointEigenSolver&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt;&gt; eigensolver(A);</span>
<span class="s2">  Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; Q = eigensolver.eigenvectors();</span>
<span class="s2">  Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; D = eigensolver.eigenvalues().array().sqrt().matrix().asDiagonal();</span>

<span class="s2">  // Compute square root and inverse square root metrics</span>
<span class="s2">  Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; Sq = Q * D * Q.transpose();</span>
<span class="s2">  Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; Sqi = Q * D.inverse() * Q.transpose();</span>

<span class="s2">  // Solve eigenvalue problem for triple product of inverse square root metric and the second metric</span>
<span class="s2">  SelfAdjointEigenSolver&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt;&gt; eigensolver2(Sqi.transpose() * B * Sqi);</span>
<span class="s2">  Q = eigensolver2.eigenvectors();</span>
<span class="s2">  D = eigensolver2.eigenvalues().array().max(1).matrix().asDiagonal();</span>

<span class="s2">  // Compute metric intersection</span>
<span class="s2">  M = Sq.transpose() * Q * D * Q.transpose() * Sq;</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_eigendecomposition"><a class="viewcode-back" href="../../pyroteus.html#pyroteus.kernel.get_eigendecomposition">[docs]</a><span class="k">def</span> <span class="nf">get_eigendecomposition</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract eigenvectors/eigenvalues from a</span>
<span class="sd">    metric field.</span>

<span class="sd">    :arg d: spatial dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;Eigen/Dense&gt;</span>

<span class="s2">using namespace Eigen;</span>

<span class="s2">void get_eigendecomposition(double EVecs_[</span><span class="si">%d</span><span class="s2">], double EVals_[</span><span class="si">%d</span><span class="s2">], const double * M_) {</span>

<span class="s2">  // Map inputs and outputs onto Eigen objects</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; EVecs((double *)EVecs_);</span>
<span class="s2">  Map&lt;Vector</span><span class="si">%d</span><span class="s2">d&gt; EVals((double *)EVals_);</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; M((double *)M_);</span>

<span class="s2">  // Solve eigenvalue problem</span>
<span class="s2">  SelfAdjointEigenSolver&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt;&gt; eigensolver(M);</span>
<span class="s2">  EVecs = eigensolver.eigenvectors();</span>
<span class="s2">  EVals = eigensolver.eigenvalues();</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_reordered_eigendecomposition"><a class="viewcode-back" href="../../pyroteus.html#pyroteus.kernel.get_reordered_eigendecomposition">[docs]</a><span class="k">def</span> <span class="nf">get_reordered_eigendecomposition</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract eigenvectors/eigenvalues from a</span>
<span class="sd">    metric field, with eigenvalues</span>
<span class="sd">    **decreasing** in magnitude.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Spatial dimension </span><span class="si">{</span><span class="n">d</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> not supported.&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;Eigen/Dense&gt;</span>

<span class="s2">using namespace Eigen;</span>

<span class="s2">void get_reordered_eigendecomposition(double EVecs_[4], double EVals_[2], const double * M_) {</span>

<span class="s2">  // Map inputs and outputs onto Eigen objects</span>
<span class="s2">  Map&lt;Matrix&lt;double, 2, 2, RowMajor&gt; &gt; EVecs((double *)EVecs_);</span>
<span class="s2">  Map&lt;Vector2d&gt; EVals((double *)EVals_);</span>
<span class="s2">  Map&lt;Matrix&lt;double, 2, 2, RowMajor&gt; &gt; M((double *)M_);</span>

<span class="s2">  // Solve eigenvalue problem</span>
<span class="s2">  SelfAdjointEigenSolver&lt;Matrix&lt;double, 2, 2, RowMajor&gt;&gt; eigensolver(M);</span>
<span class="s2">  Matrix&lt;double, 2, 2, RowMajor&gt; Q = eigensolver.eigenvectors();</span>
<span class="s2">  Vector2d D = eigensolver.eigenvalues();</span>

<span class="s2">  // Reorder eigenpairs by magnitude of eigenvalue</span>
<span class="s2">  if (fabs(D(0)) &gt; fabs(D(1))) {</span>
<span class="s2">    EVecs = Q;</span>
<span class="s2">    EVals = D;</span>
<span class="s2">  } else {</span>
<span class="s2">    EVecs(0,0) = Q(0,1);EVecs(0,1) = Q(0,0);</span>
<span class="s2">    EVecs(1,0) = Q(1,1);EVecs(1,1) = Q(1,0);</span>
<span class="s2">    EVals(0) = D(1);</span>
<span class="s2">    EVals(1) = D(0);</span>
<span class="s2">  }</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;Eigen/Dense&gt;</span>

<span class="s2">using namespace Eigen;</span>

<span class="s2">void get_reordered_eigendecomposition(double EVecs_[9], double EVals_[3], const double * M_) {</span>

<span class="s2">  // Map inputs and outputs onto Eigen objects</span>
<span class="s2">  Map&lt;Matrix&lt;double, 3, 3, RowMajor&gt; &gt; EVecs((double *)EVecs_);</span>
<span class="s2">  Map&lt;Vector3d&gt; EVals((double *)EVals_);</span>
<span class="s2">  Map&lt;Matrix&lt;double, 3, 3, RowMajor&gt; &gt; M((double *)M_);</span>

<span class="s2">  // Solve eigenvalue problem</span>
<span class="s2">  SelfAdjointEigenSolver&lt;Matrix&lt;double, 3, 3, RowMajor&gt;&gt; eigensolver(M);</span>
<span class="s2">  Matrix&lt;double, 3, 3, RowMajor&gt; Q = eigensolver.eigenvectors();</span>
<span class="s2">  Vector3d D = eigensolver.eigenvalues();</span>

<span class="s2">  // Reorder eigenpairs by magnitude of eigenvalue</span>
<span class="s2">  if (fabs(D(0)) &gt; fabs(D(1))) {</span>
<span class="s2">    if (fabs(D(1)) &gt; fabs(D(2))) {</span>
<span class="s2">      EVecs = Q;</span>
<span class="s2">      EVals = D;</span>
<span class="s2">    } else if (fabs(D(0)) &gt; fabs(D(2))) {</span>
<span class="s2">      EVecs(0,0) = Q(0,0);EVecs(0,1) = Q(0,2);EVecs(0,2) = Q(0,1);</span>
<span class="s2">      EVecs(1,0) = Q(1,0);EVecs(1,1) = Q(1,2);EVecs(1,2) = Q(1,1);</span>
<span class="s2">      EVecs(2,0) = Q(2,0);EVecs(2,1) = Q(2,2);EVecs(2,2) = Q(2,1);</span>
<span class="s2">      EVals(0) = D(0);</span>
<span class="s2">      EVals(1) = D(2);</span>
<span class="s2">      EVals(2) = D(1);</span>
<span class="s2">    } else {</span>
<span class="s2">      EVecs(0,0) = Q(0,2);EVecs(0,1) = Q(0,0);EVecs(0,2) = Q(0,1);</span>
<span class="s2">      EVecs(1,0) = Q(1,2);EVecs(1,1) = Q(1,0);EVecs(1,2) = Q(1,1);</span>
<span class="s2">      EVecs(2,0) = Q(2,2);EVecs(2,1) = Q(2,0);EVecs(2,2) = Q(2,1);</span>
<span class="s2">      EVals(0) = D(2);</span>
<span class="s2">      EVals(1) = D(0);</span>
<span class="s2">      EVals(2) = D(1);</span>
<span class="s2">    }</span>
<span class="s2">  } else {</span>
<span class="s2">    if (fabs(D(0)) &gt; fabs(D(2))) {</span>
<span class="s2">      EVecs(0,0) = Q(0,1);EVecs(0,1) = Q(0,0);EVecs(0,2) = Q(0,2);</span>
<span class="s2">      EVecs(1,0) = Q(1,1);EVecs(1,1) = Q(1,0);EVecs(1,2) = Q(1,2);</span>
<span class="s2">      EVecs(2,0) = Q(2,1);EVecs(2,1) = Q(2,0);EVecs(2,2) = Q(2,2);</span>
<span class="s2">      EVals(0) = D(1);</span>
<span class="s2">      EVals(1) = D(0);</span>
<span class="s2">      EVals(2) = D(2);</span>
<span class="s2">    } else if (fabs(D(1)) &gt; fabs(D(2))) {</span>
<span class="s2">      EVecs(0,0) = Q(0,1);EVecs(0,1) = Q(0,2);EVecs(0,2) = Q(0,0);</span>
<span class="s2">      EVecs(1,0) = Q(1,1);EVecs(1,1) = Q(1,2);EVecs(1,2) = Q(1,0);</span>
<span class="s2">      EVecs(2,0) = Q(2,1);EVecs(2,1) = Q(2,2);EVecs(2,2) = Q(2,0);</span>
<span class="s2">      EVals(0) = D(1);</span>
<span class="s2">      EVals(1) = D(2);</span>
<span class="s2">      EVals(2) = D(0);</span>
<span class="s2">    } else {</span>
<span class="s2">      EVecs(0,0) = Q(0,2);EVecs(0,1) = Q(0,1);EVecs(0,2) = Q(0,0);</span>
<span class="s2">      EVecs(1,0) = Q(1,2);EVecs(1,1) = Q(1,1);EVecs(1,2) = Q(1,0);</span>
<span class="s2">      EVecs(2,0) = Q(2,2);EVecs(2,1) = Q(2,1);EVecs(2,2) = Q(2,0);</span>
<span class="s2">      EVals(0) = D(2);</span>
<span class="s2">      EVals(1) = D(1);</span>
<span class="s2">      EVals(2) = D(0);</span>
<span class="s2">    }</span>
<span class="s2">  }</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="metric_from_hessian"><a class="viewcode-back" href="../../pyroteus.html#pyroteus.kernel.metric_from_hessian">[docs]</a><span class="k">def</span> <span class="nf">metric_from_hessian</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modify the eigenvalues of a Hessian matrix so</span>
<span class="sd">    that it is positive-definite.</span>

<span class="sd">    :arg d: spatial dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;Eigen/Dense&gt;</span>

<span class="s2">using namespace Eigen;</span>

<span class="s2">void metric_from_hessian(double A_[</span><span class="si">%d</span><span class="s2">], const double * B_) {</span>

<span class="s2">  // Map inputs and outputs onto Eigen objects</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; A((double *)A_);</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; B((double *)B_);</span>

<span class="s2">  // Compute mean diagonal and set values appropriately</span>
<span class="s2">  double mean_diag;</span>
<span class="s2">  int i,j;</span>
<span class="s2">  for (i=0; i&lt;</span><span class="si">%d</span><span class="s2">-1; i++) {</span>
<span class="s2">    for (j=i+1; i&lt;</span><span class="si">%d</span><span class="s2">; i++) {</span>
<span class="s2">      mean_diag = 0.5*(B(i,j) + B(j,i));</span>
<span class="s2">      B(i,j) = mean_diag;</span>
<span class="s2">      B(j,i) = mean_diag;</span>
<span class="s2">    }</span>
<span class="s2">  }</span>

<span class="s2">  // Solve eigenvalue problem</span>
<span class="s2">  SelfAdjointEigenSolver&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt;&gt; eigensolver(B);</span>
<span class="s2">  Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; Q = eigensolver.eigenvectors();</span>
<span class="s2">  Vector</span><span class="si">%d</span><span class="s2">d D = eigensolver.eigenvalues();</span>

<span class="s2">  // Take modulus of eigenvalues</span>
<span class="s2">  for (i=0; i&lt;</span><span class="si">%d</span><span class="s2">; i++) D(i) = fmax(1e-10, abs(D(i)));</span>

<span class="s2">  // Build metric from eigendecomposition</span>
<span class="s2">  A += Q * D.asDiagonal() * Q.transpose();</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="set_eigendecomposition"><a class="viewcode-back" href="../../pyroteus.html#pyroteus.kernel.set_eigendecomposition">[docs]</a><span class="k">def</span> <span class="nf">set_eigendecomposition</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a metric from eigenvectors</span>
<span class="sd">    and eigenvalues as an orthogonal</span>
<span class="sd">    eigendecomposition.</span>

<span class="sd">    :arg d: spatial dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;Eigen/Dense&gt;</span>

<span class="s2">using namespace Eigen;</span>

<span class="s2">void set_eigendecomposition(double M_[</span><span class="si">%d</span><span class="s2">], const double * EVecs_, const double * EVals_) {</span>

<span class="s2">  // Map inputs and outputs onto Eigen objects</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; M((double *)M_);</span>
<span class="s2">  Map&lt;Matrix&lt;double, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, RowMajor&gt; &gt; EVecs((double *)EVecs_);</span>
<span class="s2">  Map&lt;Vector</span><span class="si">%d</span><span class="s2">d&gt; EVals((double *)EVals_);</span>

<span class="s2">  // Compute metric from eigendecomposition</span>
<span class="s2">  M = EVecs * EVals.asDiagonal() * EVecs.transpose();</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Pyroteus 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyroteus.kernel</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Joseph G. Wallwork et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>