<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>movement.monge_ampere &#8212; Animate, Movement, Goalie and UM2N 0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    <script src="../../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Animate, Movement, Goalie and UM2N 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">movement.monge_ampere</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for movement.monge_ampere</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mesh movement based on solutions of equations of Monge-Ampère type.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">firedrake</span>
<span class="kn">import</span> <span class="nn">firedrake.exceptions</span> <span class="k">as</span> <span class="nn">fexc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">ufl</span>
<span class="kn">from</span> <span class="nn">firedrake.petsc</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">from</span> <span class="nn">pyadjoint</span> <span class="kn">import</span> <span class="n">no_annotations</span>

<span class="kn">import</span> <span class="nn">movement.solver_parameters</span> <span class="k">as</span> <span class="nn">solver_parameters</span>
<span class="kn">from</span> <span class="nn">movement.math</span> <span class="kn">import</span> <span class="n">equation_of_hyperplane</span>
<span class="kn">from</span> <span class="nn">movement.mover</span> <span class="kn">import</span> <span class="n">PrimeMover</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;MongeAmpereMover_Relaxation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MongeAmpereMover_QuasiNewton&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MongeAmpereMover&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="MongeAmpereMover">
<a class="viewcode-back" href="../../movement.html#movement.monge_ampere.MongeAmpereMover">[docs]</a>
<span class="k">def</span> <span class="nf">MongeAmpereMover</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">monitor_function</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;relaxation&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory function for generating Monge-Ampère mesh movers.</span>

<span class="sd">    Movement of a *mesh* is determined by a *monitor_function* :math:`m` and an equation</span>
<span class="sd">    of Monge-Ampère type,</span>

<span class="sd">    .. math::</span>
<span class="sd">        m(\mathbf{x})\det(\mathbf{I} + \mathbf{H}(\phi)) = \theta,</span>

<span class="sd">    for a convex scalar potential :math:`\phi=\phi(\boldsymbol{\xi})`, which is a</span>
<span class="sd">    function of the coordinates of the *computational* mesh. Here :math:`m=m(\mathbf{x})`</span>
<span class="sd">    is a function of the coordinates of the *physical* mesh, :math:`\mathbf{I}` is the</span>
<span class="sd">    identity matrix, :math:`\theta` is a normalisation coefficient  and</span>
<span class="sd">    :math:`\mathbf{H}(\phi)` denotes the Hessian of :math:`\phi` with respect to</span>
<span class="sd">    :math:`\boldsymbol{\xi}`.</span>

<span class="sd">    Different implementations solve the Monge-Ampère equation in different ways. If the</span>
<span class="sd">    `method` argument is set to `&quot;relaxation&quot;` then it is solved in parabolised form in</span>
<span class="sd">    :class:`~.MongeAmpereMover_Relaxation`. If the argument is set to `&quot;quasi_newton&quot;`</span>
<span class="sd">    then it is solved in its elliptic form using a quasi-Newton method in</span>
<span class="sd">    :class:`~.MongeAmpereMover_QuasiNewton`. Descriptions of both methods may be found in</span>
<span class="sd">    :cite:`MCB:18`.</span>

<span class="sd">    The physical mesh coordinates :math:`\mathbf{x}` are updated according to</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{x} = \boldsymbol{\xi} + \nabla_{\boldsymbol{\xi}}\phi.</span>

<span class="sd">    :arg mesh: the physical mesh</span>
<span class="sd">    :type mesh: :class:`firedrake.mesh.MeshGeometry`</span>
<span class="sd">    :arg monitor_function: a Python function which takes a mesh as input</span>
<span class="sd">    :type monitor_function: :class:`~.Callable`</span>
<span class="sd">    :kwarg method: choose from &#39;relaxation&#39; and &#39;quasi_newton&#39;</span>
<span class="sd">    :type method: :class:`str`</span>
<span class="sd">    :kwarg phi_init: initial guess for the scalar potential</span>
<span class="sd">    :type phi_init: :class:`firedrake.function.Function`</span>
<span class="sd">    :kwarg H_init: initial guess for the Hessian</span>
<span class="sd">    :type H_init: :class:`firedrake.function.Function`</span>
<span class="sd">    :kwarg maxiter: maximum number of iterations for the solver</span>
<span class="sd">    :type maxiter: :class:`int`</span>
<span class="sd">    :kwarg rtol: relative tolerance for the residual</span>
<span class="sd">    :type rtol: :class:`float`</span>
<span class="sd">    :kwarg dtol: divergence tolerance for the residual</span>
<span class="sd">    :type dtol: :class:`float`</span>
<span class="sd">    :kwarg pseudo_timestep: pseudo-timestep (only relevant to relaxation method)</span>
<span class="sd">    :type pseudo_timestep: :class:`float`</span>
<span class="sd">    :kwarg fixed_boundary_segments: labels corresponding to boundary segments to be fixed</span>
<span class="sd">        with a zero Dirichlet condition. The &#39;on_boundary&#39; label indicates the whole</span>
<span class="sd">        domain boundary</span>
<span class="sd">    :type fixed_boundary_segments: :class:`list` of :class:`str` or :class:`int`</span>
<span class="sd">    :return: the Monge-Ampère Mover object</span>
<span class="sd">    :rtype: :class:`MongeAmpereMover_Relaxation` or</span>
<span class="sd">        :class:`MongeAmpereMover_QuasiNewton`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">implemented_methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;relaxation&quot;</span><span class="p">:</span> <span class="n">MongeAmpereMover_Relaxation</span><span class="p">,</span>
        <span class="s2">&quot;quasi_newton&quot;</span><span class="p">:</span> <span class="n">MongeAmpereMover_QuasiNewton</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">implemented_methods</span><span class="p">[</span><span class="n">method</span><span class="p">](</span><span class="n">mesh</span><span class="p">,</span> <span class="n">monitor_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; not recognised.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span></div>



<span class="k">def</span> <span class="nf">tangential</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return component of `v` perpendicular to `n` (assumed normalised).</span>

<span class="sd">    This is used to project vectors onto the tangent plane of a boundary.</span>

<span class="sd">    :arg v: the vector to project</span>
<span class="sd">    :type v: :class:`ufl.Expr`</span>
<span class="sd">    :arg n: the normal vector</span>
<span class="sd">    :type n: :class:`ufl.Expr`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">-</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>


<span class="k">class</span> <span class="nc">MongeAmpereMover_Base</span><span class="p">(</span><span class="n">PrimeMover</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for mesh movers based on the solution of Monge-Ampère type equations.</span>

<span class="sd">    Currently implemented subclasses: :class:`~.MongeAmpereMover_Relaxation` and</span>
<span class="sd">    :class:`~.MongeAmpereMover_QuasiNewton`. Descriptions of both methods may be found in</span>
<span class="sd">    :cite:`MCB:18`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">monitor_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg mesh: the physical mesh</span>
<span class="sd">        :type mesh: :class:`firedrake.mesh.MeshGeometry`</span>
<span class="sd">        :arg monitor_function: a Python function which takes a mesh as input</span>
<span class="sd">        :type monitor_function: :class:`~.Callable`</span>
<span class="sd">        :kwarg phi_init: initial guess for the scalar potential</span>
<span class="sd">        :type phi_init: :class:`firedrake.function.Function`</span>
<span class="sd">        :kwarg H_init: initial guess for the Hessian</span>
<span class="sd">        :type H_init: :class:`firedrake.function.Function`</span>
<span class="sd">        :kwarg maxiter: maximum number of iterations for the relaxation</span>
<span class="sd">        :type maxiter: :class:`int`</span>
<span class="sd">        :kwarg rtol: relative tolerance for the residual</span>
<span class="sd">        :type rtol: :class:`float`</span>
<span class="sd">        :kwarg dtol: divergence tolerance for the residual</span>
<span class="sd">        :type dtol: :class:`float`</span>
<span class="sd">        :kwarg fixed_boundary_segments: labels corresponding to boundary segments to be</span>
<span class="sd">            fixed with a zero Dirichlet condition. The &#39;on_boundary&#39; label indicates</span>
<span class="sd">            the whole domain boundary</span>
<span class="sd">        :type fixed_boundary_segments: :class:`list` of :class:`str` or :class:`int`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">monitor_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please supply a monitor function.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> not implemented on curved meshes.&quot;</span>
            <span class="p">)</span>  <span class="c1"># TODO: (#107)</span>

        <span class="c1"># Collect parameters before calling super</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;maxiter&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;rtol&quot;</span><span class="p">,</span> <span class="mf">1.0e-08</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;dtol&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fixed_boundary_segments&quot;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">monitor_function</span><span class="o">=</span><span class="n">monitor_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Handle boundary segments where zero Dirichlet conditions are applied</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span> <span class="o">==</span> <span class="s2">&quot;on_boundary&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_boundary_segments</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_boundary_segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Provided mesh has no boundary segments with Physical ID tags. If the &quot;</span>
                <span class="s2">&quot;boundaries aren&#39;t fully periodic then this will likely cause errors.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;on_boundary&quot;</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_boundary_segments</span>
        <span class="k">for</span> <span class="n">boundary_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">boundary_tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_boundary_segments</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Provided boundary_tag &#39;</span><span class="si">{</span><span class="n">boundary_tag</span><span class="si">}</span><span class="s2">&#39; is invalid.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_function_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_create_function_spaces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P1</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P1_ten</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TensorFunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_create_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_create_functions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Monitor function&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grad_phi</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad_phi</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_volume</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_volume</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_P0</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">apply_initial_guess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi_init</span><span class="p">,</span> <span class="n">H_init</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise the approximations to the scalar potential and its Hessian with an</span>
<span class="sd">        initial guess.</span>

<span class="sd">        By default, both are initialised to zero, which corresponds to the case where the</span>
<span class="sd">        computational and physical meshes coincide.</span>

<span class="sd">        :arg phi_init: initial guess for the scalar potential</span>
<span class="sd">        :type phi_init: :class:`firedrake.function.Function`</span>
<span class="sd">        :arg H_init: initial guess for the Hessian</span>
<span class="sd">        :type H_init: :class:`firedrake.function.Function`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">phi_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">H_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">phi_init</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">H_init</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">phi_init</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">H_init</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_old</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_old</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">phi_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">H_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need to initialise both phi *and* H.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">relative_l2_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: the relative :math:`L^2` norm residual.</span>
<span class="sd">        :rtype: :class:`float`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_residual_l2_form&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_norm_l2_form&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_residual_l2_form</span><span class="p">)</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">norm</span>
            <span class="o">/</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_norm_l2_form</span><span class="p">)</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">norm</span>
        <span class="p">)</span>

    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_update_physical_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the physical coordinates :math:`\mathbf{x}` using the recovered gradient:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{x} = \boldsymbol{\xi} + \nabla_{\boldsymbol{\xi}}\phi.</span>

<span class="sd">        After updating the coordinates, this method also checks for mesh tangling if this</span>
<span class="sd">        is turned on. (It will be turned on by default in the 2D case.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_phi</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grad_phi</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_phi</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grad_phi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_phi</span><span class="p">)</span>

        <span class="c1"># Check if the mesh has become tangled</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;tangling_checker&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tangling_checker</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_l2_projector_bcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boundary_tag</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine boundary conditions to apply for the :math:`L^2` projection step for</span>
<span class="sd">        a given boundary segment.</span>

<span class="sd">        Note that the boundary segment *must* be a straight line or plane.</span>

<span class="sd">        :arg boundary_tag: tag for the boundary segment in consideration</span>
<span class="sd">        :type boundary_tag: :class:`str`</span>
<span class="sd">        :returns: tuple of boundary conditions</span>
<span class="sd">        :rtype: :class:`tuple` of :class:`~.DirichletBC`\s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zero_bc</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">DirichletBC</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">boundary_tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">boundary_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_boundary_segments</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">zero_bc</span><span class="p">,)</span>

        <span class="c1"># If the boundary segment is axis-aligned, it is straightforward to avoid</span>
        <span class="c1"># movement in the normal direction while allowing tangential movement - simply</span>
        <span class="c1"># fix the component for the appropriate coordinate</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="n">boundary_tag</span><span class="p">)</span>
        <span class="n">iszero</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span> <span class="o">*</span> <span class="n">ds</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span>
        <span class="n">nzero</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">iszero</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nzero</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">if</span> <span class="n">nzero</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">iszero</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">DirichletBC</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">boundary_tag</span><span class="p">),)</span>

        <span class="c1"># Create an equation boundary condition for enforcing no mesh movement normal to</span>
        <span class="c1"># domain boundaries</span>
        <span class="n">u_cts</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span><span class="p">)</span>
        <span class="n">v_cts</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span><span class="p">)</span>
        <span class="n">a_bc</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_cts</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_cts</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">ds</span>
        <span class="n">L_bc</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_cts</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">ds</span>
        <span class="n">bc1</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">EquationBC</span><span class="p">(</span><span class="n">a_bc</span> <span class="o">==</span> <span class="n">L_bc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grad_phi</span><span class="p">,</span> <span class="n">boundary_tag</span><span class="p">)</span>

        <span class="c1"># Determine the &#39;corner&#39; vertices which are at the intersection of two boundary</span>
        <span class="c1"># segments and create a Dirichlet condition for fixing them under mesh movement</span>
        <span class="n">facet_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_boundary_segments</span><span class="p">)</span>
        <span class="n">ffacet_indices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">boundary_tag</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">facet_indices</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="n">boundary_tag</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">ffacet_bc</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">DirichletBC</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ffacet_indices</span><span class="p">)</span>

        <span class="c1"># Check the current boundary segment is a straight line or plane</span>
        <span class="c1"># TODO: Only do the following check in debugging mode (#94)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_space</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">ffacets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_with_halos</span><span class="p">[</span><span class="n">ffacet_bc</span><span class="o">.</span><span class="n">nodes</span><span class="p">])</span>
        <span class="n">hyperplane</span> <span class="o">=</span> <span class="n">equation_of_hyperplane</span><span class="p">(</span><span class="o">*</span><span class="n">ffacets</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_with_halos</span><span class="p">[</span><span class="n">zero_bc</span><span class="o">.</span><span class="n">nodes</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">hyperplane</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Boundary segment &#39;</span><span class="si">{</span><span class="n">boundary_tag</span><span class="si">}</span><span class="s2">&#39; is not&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39;linear&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;planar&#39;</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Create an equation boundary condition which allows tangential movement, but</span>
        <span class="c1"># only up until the &#39;corner&#39; vertices where boundary segments meet</span>
        <span class="n">a_bc</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tangential</span><span class="p">(</span><span class="n">v_cts</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">tangential</span><span class="p">(</span><span class="n">u_cts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">ds</span>
        <span class="n">L_bc</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tangential</span><span class="p">(</span><span class="n">v_cts</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">tangential</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_old</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">ds</span>
        <span class="n">bc2</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">EquationBC</span><span class="p">(</span>
            <span class="n">a_bc</span> <span class="o">==</span> <span class="n">L_bc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grad_phi</span><span class="p">,</span> <span class="n">boundary_tag</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">ffacet_bc</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span>

    <span class="nd">@property</span>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">l2_projector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a linear solver for obtaining the gradient of the potential using an</span>
<span class="sd">        :math:`L^2` projection.</span>

<span class="sd">        :return: the linear solver</span>
<span class="sd">        :rtype: :class:`~.LinearVariationalSolver`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_l2_projector&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2_projector</span>
        <span class="n">u_cts</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span><span class="p">)</span>
        <span class="n">v_cts</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_vec</span><span class="p">)</span>

        <span class="c1"># Domain interior</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">v_cts</span><span class="p">,</span> <span class="n">u_cts</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">v_cts</span><span class="p">,</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_old</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

        <span class="c1"># Enforce no movement normal to boundary</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dirichlet_bc</span>
            <span class="k">for</span> <span class="n">boundary_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_boundary_segments</span>
            <span class="k">for</span> <span class="n">dirichlet_bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2_projector_bcs</span><span class="p">(</span><span class="n">boundary_tag</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Create solver</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grad_phi</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l2_projector</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">LinearVariationalSolver</span><span class="p">(</span>
            <span class="n">problem</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="o">.</span><span class="n">cg_ilu</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2_projector</span>


<div class="viewcode-block" id="MongeAmpereMover_Relaxation">
<a class="viewcode-back" href="../../movement.html#movement.monge_ampere.MongeAmpereMover_Relaxation">[docs]</a>
<span class="k">class</span> <span class="nc">MongeAmpereMover_Relaxation</span><span class="p">(</span><span class="n">MongeAmpereMover_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The standard, elliptic form of the Monge-Ampère equation used for mesh movement is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        m(\mathbf{x})\det(\mathbf{I} + \mathbf{H}(\phi)) = \theta,</span>

<span class="sd">    for a convex scalar potential :math:`\phi=\phi(\boldsymbol{\xi})`, which is a</span>
<span class="sd">    function of the coordinates of the *computational* mesh. Here :math:`m=m(\mathbf{x})`</span>
<span class="sd">    is a user-provided monitor function, which is a function of the coordinates of the</span>
<span class="sd">    *physical* mesh. :math:`\mathbf{I}` is the identity matrix, :math:`\theta` is a</span>
<span class="sd">    normalisation coefficient  and :math:`\mathbf{H}(\phi)` denotes the Hessian of</span>
<span class="sd">    :math:`\phi` with respect to :math:`\boldsymbol{\xi}`.</span>

<span class="sd">    In this mesh mover, the Monge-Ampère equation is instead solved in a parabolised form</span>
<span class="sd">    using a pseudo-time relaxation,</span>

<span class="sd">    .. math::</span>
<span class="sd">        -\frac\partial{\partial\tau}\Delta\phi</span>
<span class="sd">        = m(\mathbf{x})\det(\mathbf{I} + \mathbf{H}(\phi)) - \theta,</span>

<span class="sd">    where :math:`\tau` is the pseudo-time variable. Forward Euler is used for the</span>
<span class="sd">    pseudo-time integration (see :cite:`MCB:18` for details).</span>

<span class="sd">    This approach typically takes tens or hundreds of iterations to converge, but each</span>
<span class="sd">    iteration is relatively cheap.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">monitor_function</span><span class="p">,</span> <span class="n">phi_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">H_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg mesh: the physical mesh</span>
<span class="sd">        :type mesh: :class:`firedrake.mesh.MeshGeometry`</span>
<span class="sd">        :arg monitor_function: a Python function which takes a mesh as input</span>
<span class="sd">        :type monitor_function: :class:`~.Callable`</span>
<span class="sd">        :kwarg phi_init: initial guess for the scalar potential</span>
<span class="sd">        :type phi_init: :class:`firedrake.function.Function`</span>
<span class="sd">        :kwarg H_init: initial guess for the Hessian</span>
<span class="sd">        :type H_init: :class:`firedrake.function.Function`</span>
<span class="sd">        :kwarg pseudo_timestep: pseudo-timestep to use for the relaxation</span>
<span class="sd">        :type pseudo_timestep: :class:`float`</span>
<span class="sd">        :kwarg maxiter: maximum number of iterations for the relaxation</span>
<span class="sd">        :type maxiter: :class:`int`</span>
<span class="sd">        :kwarg rtol: relative tolerance for the residual</span>
<span class="sd">        :type rtol: :class:`float`</span>
<span class="sd">        :kwarg dtol: divergence tolerance for the residual</span>
<span class="sd">        :type dtol: :class:`float`</span>
<span class="sd">        :kwarg fixed_boundary_segments: labels corresponding to boundary segments to be</span>
<span class="sd">            fixed with a zero Dirichlet condition. The &#39;on_boundary&#39; label indicates</span>
<span class="sd">            the whole domain boundary</span>
<span class="sd">        :type fixed_boundary_segments: :class:`list` of :class:`str` or :class:`int`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dt</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;pseudo_timestep&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">monitor_function</span><span class="o">=</span><span class="n">monitor_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Initialise phi and H</span>
        <span class="k">if</span> <span class="n">phi_init</span> <span class="ow">or</span> <span class="n">H_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_initial_guess</span><span class="p">(</span><span class="n">phi_init</span><span class="p">,</span> <span class="n">H_init</span><span class="p">)</span>

        <span class="c1"># Setup residuals</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_old</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_old</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_residual_l2_form</span> <span class="o">=</span> <span class="n">psi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm_l2_form</span> <span class="o">=</span> <span class="n">psi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

    <span class="k">def</span> <span class="nf">_create_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_create_functions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_ten</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_old</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_old</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_ten</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">pseudotimestepper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup the pseudo-timestepper for the relaxation method.</span>

<span class="sd">        Forward Euler is used for the pseudo-time integration (see :cite:`MCB:18` for</span>
<span class="sd">        details). The pseudo-timestep may be set through the `pseudo_timestep` keyword</span>
<span class="sd">        argument to the constructor.</span>

<span class="sd">        :return: the pseudo-timestepper</span>
<span class="sd">        :rtype: :class:`~.LinearVariationalSolver`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_pseudotimestepper&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudotimestepper</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_old</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudo_dt</span> <span class="o">*</span> <span class="n">psi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="p">)</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">nullspace</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">VectorSpaceBasis</span><span class="p">(</span><span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pseudotimestepper</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">LinearVariationalSolver</span><span class="p">(</span>
            <span class="n">problem</span><span class="p">,</span>
            <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="o">.</span><span class="n">cg_gamg</span><span class="p">,</span>
            <span class="n">nullspace</span><span class="o">=</span><span class="n">nullspace</span><span class="p">,</span>
            <span class="n">transpose_nullspace</span><span class="o">=</span><span class="n">nullspace</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudotimestepper</span>

    <span class="nd">@property</span>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">equidistributor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup the equidistributor for the relaxation method.</span>

<span class="sd">        The equidistributor solves the following equation:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \int_{\Omega} \tau : \mathbf{H} \, \mathrm{d}x</span>
<span class="sd">            = -\int_{\Omega} (\nabla \cdot \tau) \cdot (\nabla \phi) \, \mathrm{d}x</span>
<span class="sd">            + \int_{\partial \Omega} ((\nabla \phi \cdot \widehat{\mathbf{n}}) \cdot</span>
<span class="sd">            \tau) \cdot \widehat{\mathbf{n}} \, \mathrm{d}s,</span>
<span class="sd">            \quad \forall \tau \in \mathbb{P}1^{d \times d}</span>

<span class="sd">        for the Hessian :math:`\mathbf{H}`, where :math:`d` is the spatial dimension and</span>
<span class="sd">        :math:`\widehat{\mathbf{n}}` is a normal vector to the boundary.</span>

<span class="sd">        :return: the equidistributor</span>
<span class="sd">        :rtype: :class:`~.LinearVariationalSolver`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_equidistributor&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equidistributor</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_ten</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1_ten</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="o">+</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tangential</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="n">n</span><span class="p">),</span> <span class="n">tau</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span>
        <span class="p">)</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_equidistributor</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">LinearVariationalSolver</span><span class="p">(</span>
            <span class="n">problem</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">solver_parameters</span><span class="o">.</span><span class="n">cg_ilu</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equidistributor</span>

<div class="viewcode-block" id="MongeAmpereMover_Relaxation.move">
<a class="viewcode-back" href="../../movement.html#movement.monge_ampere.MongeAmpereMover_Relaxation.move">[docs]</a>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the relaxation method to convergence and update the mesh.</span>

<span class="sd">        :return: the iteration count</span>
<span class="sd">        :rtype: :class:`int`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Switch to computational coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_computational_coordinates</span><span class="p">()</span>

        <span class="c1"># Take iterations of the relaxed system until reaching convergence</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l2_projector</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_physical_coordinates</span><span class="p">()</span>

            <span class="c1"># Update monitor function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_physical_coordinates</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
            <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L_P0</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_volume</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_computational_coordinates</span><span class="p">()</span>

            <span class="c1"># Evaluate normalisation coefficient</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta_form</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_volume</span><span class="p">)</span>

            <span class="c1"># Check convergence criteria</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_l2_residual</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">initial_norm</span> <span class="o">=</span> <span class="n">residual</span>
            <span class="n">PETSc</span><span class="o">.</span><span class="n">Sys</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;   Volume ratio </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_ratio</span><span class="si">:</span><span class="s2">5.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;   Variation (σ/μ) </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficient_of_variation</span><span class="si">:</span><span class="s2">8.2e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;   Residual </span><span class="si">{</span><span class="n">residual</span><span class="si">:</span><span class="s2">8.2e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">residual</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_convergence_message</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">residual</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtol</span> <span class="o">*</span> <span class="n">initial_norm</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_divergence_error</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_convergence_error</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Apply pseudotimestepper and equidistributor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pseudotimestepper</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equidistributor</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_old</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_old</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_physical_coordinates</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">i</span></div>
</div>



<div class="viewcode-block" id="MongeAmpereMover_QuasiNewton">
<a class="viewcode-back" href="../../movement.html#movement.monge_ampere.MongeAmpereMover_QuasiNewton">[docs]</a>
<span class="k">class</span> <span class="nc">MongeAmpereMover_QuasiNewton</span><span class="p">(</span><span class="n">MongeAmpereMover_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The standard, elliptic form of the Monge-Ampère equation used for mesh movement is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        m(\mathbf{x})\det(\mathbf{I} + \mathbf{H}(\phi)) = \theta,</span>

<span class="sd">    for a convex scalar potential :math:`\phi=\phi(\boldsymbol{\xi})`, which is a</span>
<span class="sd">    function of the coordinates of the *computational* mesh. Here :math:`m=m(\mathbf{x})`</span>
<span class="sd">    is a user-provided monitor function, which is a function of the coordinates of the</span>
<span class="sd">    *physical* mesh. :math:`\mathbf{I}` is the identity matrix, :math:`\theta` is a</span>
<span class="sd">    normalisation coefficient  and :math:`\mathbf{H}(\phi)` denotes the Hessian of</span>
<span class="sd">    :math:`\phi` with respect to :math:`\boldsymbol{\xi}`.</span>

<span class="sd">    In this mesh mover, the elliptic Monge-Ampère equation is solved using a quasi-Newton</span>
<span class="sd">    method (see :cite:`MCB:18` for details).</span>

<span class="sd">    This approach typically takes fewer than ten iterations to converge, but each</span>
<span class="sd">    iteration is relatively expensive.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">monitor_function</span><span class="p">,</span> <span class="n">phi_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">H_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg mesh: the physical mesh</span>
<span class="sd">        :type mesh: :class:`firedrake.mesh.MeshGeometry`</span>
<span class="sd">        :arg monitor_function: a Python function which takes a mesh as input</span>
<span class="sd">        :type monitor_function: :class:`~.Callable`</span>
<span class="sd">        :kwarg phi_init: initial guess for the scalar potential</span>
<span class="sd">        :type phi_init: :class:`firedrake.function.Function`</span>
<span class="sd">        :kwarg H_init: initial guess for the Hessian</span>
<span class="sd">        :type H_init: :class:`firedrake.function.Function`</span>
<span class="sd">        :kwarg maxiter: maximum number of iterations for the Quasi-Newton solver</span>
<span class="sd">        :type maxiter: :class:`int`</span>
<span class="sd">        :kwarg rtol: relative tolerance for the residual</span>
<span class="sd">        :type rtol: :class:`float`</span>
<span class="sd">        :kwarg dtol: divergence tolerance for the residual</span>
<span class="sd">        :type dtol: :class:`float`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">monitor_function</span><span class="o">=</span><span class="n">monitor_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Initialise phi and H</span>
        <span class="k">if</span> <span class="n">phi_init</span> <span class="ow">or</span> <span class="n">H_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_initial_guess</span><span class="p">(</span><span class="n">phi_init</span><span class="p">,</span> <span class="n">H_init</span><span class="p">)</span>

        <span class="c1"># Setup residuals</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_old</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_old</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_residual_l2_form</span> <span class="o">=</span> <span class="n">psi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm_l2_form</span> <span class="o">=</span> <span class="n">psi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

    <span class="k">def</span> <span class="nf">_create_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_create_functions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">P1_ten</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_and_hessian</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_and_hessian</span><span class="o">.</span><span class="n">subfunctions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_and_hessian_old</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_old</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_and_hessian_old</span><span class="o">.</span><span class="n">subfunctions</span>

    <span class="nd">@property</span>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">equidistributor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup the equidistributor for the quasi-newton method.</span>

<span class="sd">        The equidistributor solves</span>

<span class="sd">        .. math::</span>
<span class="sd">            \int_{\Omega} \boldsymbol{\tau} \cdot \mathbf{H} \, \mathrm{d}x</span>
<span class="sd">            + \int_{\Omega} (\nabla \cdot \boldsymbol{\tau}) \cdot (\nabla \phi) \,</span>
<span class="sd">            \mathrm{d}x</span>
<span class="sd">            - \int_{\partial \Omega} (((\nabla \phi) \cdot \widehat{\mathbf{n}}) \cdot</span>
<span class="sd">              \boldsymbol{\tau}) \cdot \widehat{\mathbf{n}} \, \mathrm{d}s</span>
<span class="sd">            - \int_{\Omega} \psi (m \det(\mathbf{I} + \mathbf{H}) - \theta) \,</span>
<span class="sd">              \mathrm{d}x = 0,</span>
<span class="sd">              \quad \forall \boldsymbol{\tau} \in \mathbb{P}1^{d \times d},</span>
<span class="sd">              \quad \forall \psi \in \mathbb{P}1,</span>

<span class="sd">        for the potential :math:`\phi` and its Hessian :math:`\mathbf{H}`, where</span>
<span class="sd">        :math:`d` is the spatial dimension and :math:`\widehat{\mathbf{n}}` is a normal</span>
<span class="sd">        vector to the boundary.</span>

<span class="sd">        :return: the equidistributor</span>
<span class="sd">        :rtype: :class:`~.NonlinearVariationalSolver`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_equidistributor&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equidistributor</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">Identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">phi</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_and_hessian</span><span class="p">)</span>
        <span class="n">psi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunctions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="o">+</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="o">-</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tangential</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">n</span><span class="p">),</span> <span class="n">tau</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span>
            <span class="o">-</span> <span class="n">psi</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="p">)</span>
        <span class="n">phi</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TrialFunctions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>

        <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;MongeAmpereMover.update_monitor&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">update_monitor</span><span class="p">(</span><span class="n">cursol</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Callback for updating the monitor function.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_and_hessian_old</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">vec</span> <span class="k">as</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">cursol</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l2_projector</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_physical_coordinates</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_physical_coordinates</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_computational_coordinates</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
                <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta_form</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_volume</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Setup the variational problem</span>
        <span class="c1"># =============================</span>
        <span class="c1"># We use a custom preconditioner Jp, chosen to approximate the Jacobian of the</span>
        <span class="c1"># system. It includes terms that represent the inner product of tau and H,</span>
        <span class="c1"># the product of phi and psi, and the inner product of the gradients of phi and</span>
        <span class="c1"># psi. This helps in stabilising the solver and improving convergence.</span>
        <span class="n">Jp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="o">+</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">psi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="o">+</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">psi</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="p">)</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">NonlinearVariationalProblem</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_and_hessian</span><span class="p">,</span> <span class="n">Jp</span><span class="o">=</span><span class="n">Jp</span><span class="p">)</span>

        <span class="c1"># Setup the variational solver</span>
        <span class="c1"># ============================</span>
        <span class="c1"># A nullspace is defined to handle the invariance of the solution under certain</span>
        <span class="c1"># transformations. The first component is a constant vector space basis, since</span>
        <span class="c1"># constant shifts in phi do not affect the solution.</span>
        <span class="n">nullspace</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">MixedVectorSpaceBasis</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="p">[</span><span class="n">firedrake</span><span class="o">.</span><span class="n">VectorSpaceBasis</span><span class="p">(</span><span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="c1"># Note that different solver parameters are used for serial and parallel runs</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">solver_parameters</span><span class="o">.</span><span class="n">serial_qn</span>
            <span class="k">if</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="n">solver_parameters</span><span class="o">.</span><span class="n">parallel_qn</span>
        <span class="p">)</span>
        <span class="n">sp</span><span class="p">[</span><span class="s2">&quot;snes_atol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span>
        <span class="n">sp</span><span class="p">[</span><span class="s2">&quot;snes_max_it&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_equidistributor</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">NonlinearVariationalSolver</span><span class="p">(</span>
            <span class="n">problem</span><span class="p">,</span>
            <span class="n">nullspace</span><span class="o">=</span><span class="n">nullspace</span><span class="p">,</span>
            <span class="n">transpose_nullspace</span><span class="o">=</span><span class="n">nullspace</span><span class="p">,</span>
            <span class="n">pre_function_callback</span><span class="o">=</span><span class="n">update_monitor</span><span class="p">,</span>
            <span class="n">pre_jacobian_callback</span><span class="o">=</span><span class="n">update_monitor</span><span class="p">,</span>
            <span class="n">solver_parameters</span><span class="o">=</span><span class="n">sp</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="nd">@no_annotations</span>
        <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">(</span><span class="s2">&quot;MongeAmpereMover.callback&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">snes</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Print progress of the optimisation to screen.</span>

<span class="sd">            Note that convergence is not actually checked.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">cursol</span> <span class="o">=</span> <span class="n">snes</span><span class="o">.</span><span class="n">getSolution</span><span class="p">()</span>
            <span class="n">update_monitor</span><span class="p">(</span><span class="n">cursol</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_physical_coordinates</span><span class="p">()</span>
            <span class="n">firedrake</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L_P0</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_volume</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_computational_coordinates</span><span class="p">()</span>
            <span class="n">PETSc</span><span class="o">.</span><span class="n">Sys</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;   Volume ratio </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_ratio</span><span class="si">:</span><span class="s2">5.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;   Variation (σ/μ) </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficient_of_variation</span><span class="si">:</span><span class="s2">8.2e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;   Residual </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_l2_residual</span><span class="si">:</span><span class="s2">8.2e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">snes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equidistributor</span><span class="o">.</span><span class="n">snes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snes</span><span class="o">.</span><span class="n">setMonitor</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equidistributor</span>

<div class="viewcode-block" id="MongeAmpereMover_QuasiNewton.move">
<a class="viewcode-back" href="../../movement.html#movement.monge_ampere.MongeAmpereMover_QuasiNewton.move">[docs]</a>
    <span class="nd">@PETSc</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">EventDecorator</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the quasi-Newton method to convergence and update the mesh.</span>

<span class="sd">        :return: the iteration count</span>
<span class="sd">        :rtype: :class:`int`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Solve equidistribution problem, handling convergence errors according to</span>
        <span class="c1"># desired behaviour</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equidistributor</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_convergence_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snes</span><span class="o">.</span><span class="n">getIterationNumber</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">fexc</span><span class="o">.</span><span class="n">ConvergenceError</span> <span class="k">as</span> <span class="n">conv_err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_convergence_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snes</span><span class="o">.</span><span class="n">getIterationNumber</span><span class="p">(),</span> <span class="n">exception</span><span class="o">=</span><span class="n">conv_err</span><span class="p">)</span>

        <span class="c1"># Update mesh coordinates accordingly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_physical_coordinates</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snes</span><span class="o">.</span><span class="n">getIterationNumber</span><span class="p">()</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Animate, Movement, Goalie and UM2N 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">movement.monge_ampere</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021-2024, Joseph G. Wallwork et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    </div>
  </body>
</html>