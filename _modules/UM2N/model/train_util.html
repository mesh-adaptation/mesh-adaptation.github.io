<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>UM2N.model.train_util &#8212; Animate, Movement, Goalie and UM2N 0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    <script src="../../../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Animate, Movement, Goalie and UM2N 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">UM2N.model.train_util</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for UM2N.model.train_util</h1><div class="highlight"><pre>
<span></span><span class="c1"># Author: Chunyang Wang</span>
<span class="c1"># GitHub Username: acse-cw1722</span>
<span class="c1"># Modified by Mingrui Zhang</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pytorch3d.loss</span> <span class="kn">import</span> <span class="n">chamfer_distance</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># FIXME: Hack to build the docs without this tricky dependency</span>
    <span class="n">chamfer_distance</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="kc">None</span>
<span class="kn">from</span> <span class="nn">torch_geometric.loader</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">torch_geometric.nn</span> <span class="kn">import</span> <span class="n">MessagePassing</span><span class="p">,</span> <span class="n">knn_graph</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;train&quot;</span><span class="p">,</span>
    <span class="s2">&quot;train_unsupervised&quot;</span><span class="p">,</span>
    <span class="s2">&quot;evaluate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;evaluate_unsupervised&quot;</span><span class="p">,</span>
    <span class="s2">&quot;load_model&quot;</span><span class="p">,</span>
    <span class="s2">&quot;TangleCounter&quot;</span><span class="p">,</span>
    <span class="s2">&quot;count_dataset_tangle&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_jacob_det&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_inversion_diff_loss&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_face_area&quot;</span><span class="p">,</span>
    <span class="s2">&quot;count_dataset_tangle&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_jacob_det&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_face_area&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_inversion_loss&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_inversion_node_loss&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_area_loss&quot;</span><span class="p">,</span>
    <span class="s2">&quot;evaluate_repeat_sampling&quot;</span><span class="p">,</span>
    <span class="s2">&quot;count_dataset_tangle_repeat_sampling&quot;</span><span class="p">,</span>
    <span class="s2">&quot;evaluate_repeat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_sample_tangle&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="get_face_area">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.get_face_area">[docs]</a>
<span class="k">def</span> <span class="nf">get_face_area</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">face</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the area of a face. using formula:</span>
<span class="sd">        area = 0.5 * (x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2))</span>
<span class="sd">    Args:</span>
<span class="sd">        coord (torch.Tensor): The coordinates.</span>
<span class="sd">        face (torch.Tensor): The face tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">face</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">face</span><span class="p">]</span>

    <span class="n">area</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">area</span></div>



<div class="viewcode-block" id="get_inversion_loss">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.get_inversion_loss">[docs]</a>
<span class="k">def</span> <span class="nf">get_inversion_loss</span><span class="p">(</span>
    <span class="n">out_coord</span><span class="p">,</span> <span class="n">in_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;relu&quot;</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the inversion loss for a batch of meshes.</span>
<span class="sd">    Args:</span>
<span class="sd">        out_coord (torch.Tensor): The output coordinates.</span>
<span class="sd">        in_coord (torch.Tensor): The input coordinates.</span>
<span class="sd">        face (torch.Tensor): The face tensor.</span>
<span class="sd">        batch_size (int): The batch size.</span>
<span class="sd">        alpha (float): The loss weight.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">out_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="n">in_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">in_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="c1"># restore the sign of the area, ans scale it</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">in_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_area</span>
    <span class="c1"># hard penalty, use hard condition to penalize the negative area</span>
    <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s2">&quot;hard&quot;</span><span class="p">:</span>
        <span class="c1"># mask for negative area</span>
        <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">out_area</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">neg_area</span> <span class="o">=</span> <span class="n">out_area</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span>
        <span class="n">tar_area</span> <span class="o">=</span> <span class="n">in_area</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span>
        <span class="c1"># loss should be positive, so we are using -1 here.</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">((</span><span class="n">neg_area</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tar_area</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">/</span> <span class="n">batch_size</span>
    <span class="c1"># soft penalty, peanlize the negative area harder than the positive area</span>
    <span class="k">elif</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s2">&quot;relu&quot;</span><span class="p">:</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">out_area</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">in_area</span><span class="p">)))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">batch_size</span>
    <span class="k">elif</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">out_area</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">in_area</span><span class="p">)))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">epsilon</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">batch_size</span>
    <span class="k">return</span> <span class="n">scaler</span> <span class="o">*</span> <span class="n">loss</span></div>



<div class="viewcode-block" id="get_inversion_diff_loss">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.get_inversion_diff_loss">[docs]</a>
<span class="k">def</span> <span class="nf">get_inversion_diff_loss</span><span class="p">(</span><span class="n">out_coord</span><span class="p">,</span> <span class="n">tar_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the inversion difference loss for a batch of meshes.</span>
<span class="sd">    That is the difference between the output area and the input area,</span>
<span class="sd">    in terms of the invereted elements.</span>
<span class="sd">    Args:</span>
<span class="sd">        out_coord (torch.Tensor): The output coordinates.</span>
<span class="sd">        tar_coord (torch.Tensor): The target coordinates.</span>
<span class="sd">        face (torch.Tensor): The face tensor.</span>
<span class="sd">        batch_size (int): The batch size.</span>
<span class="sd">        alpha (float): The loss weight.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">out_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="n">tar_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">tar_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="c1"># restore the sign of the area, ans scale it</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">scaler</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">tar_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_area</span>
    <span class="n">tar_area</span> <span class="o">=</span> <span class="n">scaler</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">tar_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">tar_area</span>
    <span class="c1"># mask for negative area</span>
    <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">out_area</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="n">inversion_diff</span> <span class="o">=</span> <span class="n">tar_area</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_area</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span>
    <span class="c1"># loss should be positive, so we are using -1 here.</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">inversion_diff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">batch_size</span>
    <span class="k">return</span> <span class="n">loss</span></div>



<div class="viewcode-block" id="get_inversion_node_loss">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.get_inversion_node_loss">[docs]</a>
<span class="k">def</span> <span class="nf">get_inversion_node_loss</span><span class="p">(</span><span class="n">out_coord</span><span class="p">,</span> <span class="n">tar_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the loss between the ouput node and input node, for the inverted</span>
<span class="sd">    elements. This will penalise the node which are involved in the tangled</span>
<span class="sd">    elements.</span>
<span class="sd">    Args:</span>
<span class="sd">        out_coord (torch.Tensor): The output coordinates.</span>
<span class="sd">        tar_coord (torch.Tensor): The target coordinates.</span>
<span class="sd">        face (torch.Tensor): The face tensor.</span>
<span class="sd">        batch_size (int): The batch size.</span>
<span class="sd">        alpha (float): The loss weight.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">L1Loss</span><span class="p">()</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">out_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="n">tar_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">tar_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="c1"># restore the sign of the area, ans scale it</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">tar_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_area</span>
    <span class="n">tar_area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">tar_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">tar_area</span>
    <span class="c1"># mask for negative area</span>
    <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">out_area</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="n">neg_face</span> <span class="o">=</span> <span class="n">face</span><span class="p">[:,</span> <span class="n">neg_mask</span><span class="p">]</span>
    <span class="n">neg_face</span> <span class="o">=</span> <span class="n">neg_face</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">inv_nodes</span> <span class="o">=</span> <span class="n">out_coord</span><span class="p">[</span><span class="n">neg_face</span><span class="p">]</span>
    <span class="n">tar_nodes</span> <span class="o">=</span> <span class="n">tar_coord</span><span class="p">[</span><span class="n">neg_face</span><span class="p">]</span>

    <span class="n">node_diff</span> <span class="o">=</span> <span class="n">scaler</span> <span class="o">*</span> <span class="n">loss</span><span class="p">(</span><span class="n">inv_nodes</span><span class="p">,</span> <span class="n">tar_nodes</span><span class="p">)</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="n">node_diff</span> <span class="o">/</span> <span class="n">batch_size</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
        <span class="mf">0.0</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">out_coord</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_coord</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">loss</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">zero</span></div>



<div class="viewcode-block" id="get_area_loss">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.get_area_loss">[docs]</a>
<span class="k">def</span> <span class="nf">get_area_loss</span><span class="p">(</span><span class="n">out_coord</span><span class="p">,</span> <span class="n">tar_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">out_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="n">tar_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">tar_coord</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="c1"># restore the sign of the area, ans scale it</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">scaler</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">tar_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_area</span>
    <span class="n">tar_area</span> <span class="o">=</span> <span class="n">scaler</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">tar_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">tar_area</span>
    <span class="c1"># mask for negative area</span>
    <span class="n">area_diff</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tar_area</span> <span class="o">-</span> <span class="n">out_area</span><span class="p">)</span>
    <span class="c1"># area_diff = tar_area - out_area + 100</span>
    <span class="c1"># loss should be positive, so we are using -1 here.</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="p">(</span><span class="n">area_diff</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">/</span> <span class="n">batch_size</span>
    <span class="k">return</span> <span class="n">loss</span></div>



<span class="k">def</span> <span class="nf">jacobLoss</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">):</span>
    <span class="n">jacob_det</span> <span class="o">=</span> <span class="n">get_jacob_det</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">u_loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="n">jacob_det_loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">jacob_det</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">jacobian_det</span><span class="p">)</span>
    <span class="c1"># print(&quot;using jacobian&quot;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;u_loss: &quot;</span><span class="p">,</span> <span class="n">u_loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;jacob_det_loss: &quot;</span><span class="p">,</span> <span class="n">jacob_det_loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">u_loss</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">jacob_det_loss</span>


<div class="viewcode-block" id="get_jacob_det">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.get_jacob_det">[docs]</a>
<span class="k">def</span> <span class="nf">get_jacob_det</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">in_data</span><span class="p">):</span>
    <span class="n">in_data</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">in_data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">in_data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>

    <span class="n">dXdx1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
        <span class="n">outputs</span><span class="o">=</span><span class="n">out</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">in_data</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
        <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">create_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">grad_outputs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">out</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">dXdy1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
        <span class="n">outputs</span><span class="o">=</span><span class="n">out</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">in_data</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
        <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">create_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">grad_outputs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">out</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">dXdx2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
        <span class="n">outputs</span><span class="o">=</span><span class="n">out</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">in_data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">,</span>
        <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">create_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">grad_outputs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">out</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">dXdy2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
        <span class="n">outputs</span><span class="o">=</span><span class="n">out</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">in_data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">,</span>
        <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">create_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">grad_outputs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">out</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">dXdx</span> <span class="o">=</span> <span class="n">dXdx1</span> <span class="o">+</span> <span class="n">dXdx2</span>
    <span class="n">dXdy</span> <span class="o">=</span> <span class="n">dXdy1</span> <span class="o">+</span> <span class="n">dXdy2</span>

    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">dXdx</span><span class="p">,</span> <span class="n">dXdy</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">determinant</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">jacobian</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">jacobian</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">jacobian</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">jacobian</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">determinant</span></div>



<div class="viewcode-block" id="TangleCounter">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.TangleCounter">[docs]</a>
<span class="k">class</span> <span class="nc">TangleCounter</span><span class="p">(</span><span class="n">MessagePassing</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A PyTorch Geometric Message Passing class for counting tangles in the mesh.</span>
<span class="sd">    This class is deprecated, do not use this option unless you know what you</span>
<span class="sd">    are doing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_feat</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">aggr</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_tangle</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="TangleCounter.forward">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.TangleCounter.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">propagate</span><span class="p">(</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">x_new</span><span class="o">=</span><span class="n">x_new</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_tangle</span></div>


<div class="viewcode-block" id="TangleCounter.message">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.TangleCounter.message">[docs]</a>
    <span class="k">def</span> <span class="nf">message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_i</span><span class="p">,</span> <span class="n">x_j</span><span class="p">,</span> <span class="n">x_new_i</span><span class="p">,</span> <span class="n">x_new_j</span><span class="p">):</span>
        <span class="n">coord_dim</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">x_i</span> <span class="o">=</span> <span class="n">x_i</span><span class="p">[:,</span> <span class="p">:</span><span class="n">coord_dim</span><span class="p">]</span>
        <span class="n">x_j</span> <span class="o">=</span> <span class="n">x_j</span><span class="p">[:,</span> <span class="p">:</span><span class="n">coord_dim</span><span class="p">]</span>
        <span class="n">x_new_i</span> <span class="o">=</span> <span class="n">x_new_i</span><span class="p">[:,</span> <span class="p">:</span><span class="n">coord_dim</span><span class="p">]</span>
        <span class="n">x_new_j</span> <span class="o">=</span> <span class="n">x_new_j</span><span class="p">[:,</span> <span class="p">:</span><span class="n">coord_dim</span><span class="p">]</span>

        <span class="n">diff_x</span> <span class="o">=</span> <span class="n">x_i</span> <span class="o">-</span> <span class="n">x_j</span>
        <span class="n">diff_x_new</span> <span class="o">=</span> <span class="n">x_new_i</span> <span class="o">-</span> <span class="n">x_new_j</span>

        <span class="n">tangle</span> <span class="o">=</span> <span class="n">diff_x</span> <span class="o">*</span> <span class="n">diff_x_new</span>
        <span class="n">tangle_arr</span> <span class="o">=</span> <span class="n">tangle</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_tangle</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tangle_arr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tangle</span></div>
</div>



<span class="c1"># def count_dataset_tangle(dataset, model, device, method=&quot;inversion&quot;):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Computes the average number of tangles in a dataset.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         dataset (Dataset): The PyTorch Geometric dataset.</span>
<span class="c1">#         model (torch.nn.Module): The PyTorch model.</span>
<span class="c1">#         device (torch.device): The device to run the computation.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         float: The average number of tangles in the dataset.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     model.eval()</span>
<span class="c1">#     num_tangle = 0</span>
<span class="c1">#     if (method == &quot;inversion&quot;):</span>
<span class="c1">#         loader = DataLoader(dataset=dataset, batch_size=1,</span>
<span class="c1">#                             shuffle=False)</span>
<span class="c1">#         for data in loader:</span>
<span class="c1">#             with torch.no_grad():</span>
<span class="c1">#                 output_data = model(data.to(device))</span>
<span class="c1">#                 out_area = get_face_area(output_data, data.face)</span>
<span class="c1">#                 in_area = get_face_area(data.x[:, :2], data.face)</span>
<span class="c1">#                 # restore the sign of the area</span>
<span class="c1">#                 out_area = torch.sign(in_area) * out_area</span>
<span class="c1">#                 # mask for negative area</span>
<span class="c1">#                 neg_mask = out_area &lt; 0</span>
<span class="c1">#                 neg_area = out_area[neg_mask]</span>
<span class="c1">#                 # calculate the loss, we want it normalized by the batch size</span>
<span class="c1">#                 # and loss should be positive, so we are using -1 here.</span>
<span class="c1">#                 num_tangle += len(neg_area)</span>
<span class="c1">#         return num_tangle / len(dataset)</span>

<span class="c1">#     # deprecated, do not use this option unless you know what you are doing</span>
<span class="c1">#     elif (method == &quot;msg&quot;):</span>
<span class="c1">#         for i in range(len(dataset)):</span>
<span class="c1">#             data = dataset[i].to(device)</span>
<span class="c1">#             with torch.no_grad():</span>
<span class="c1">#                 output_data = model(data)</span>
<span class="c1">#                 input_edge = data.edge_index</span>
<span class="c1">#                 mesh = data.x[:, :2]</span>
<span class="c1">#                 mesh_new = output_data</span>
<span class="c1">#                 Counter = TangleCounter()</span>
<span class="c1">#                 num_tangle += Counter(mesh, mesh_new, input_edge).item()</span>
<span class="c1">#         num_tangle = num_tangle / len(dataset)</span>
<span class="c1">#         return num_tangle</span>


<span class="c1"># def count_dataset_tangle(dataset, model, device, method=&quot;inversion&quot;):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Computes the average number of tangles in a dataset.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         dataset (Dataset): The PyTorch Geometric dataset.</span>
<span class="c1">#         model (torch.nn.Module): The PyTorch model.</span>
<span class="c1">#         device (torch.device): The device to run the computation.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         float: The average number of tangles in the dataset.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     model.eval()</span>
<span class="c1">#     num_tangle = 0</span>
<span class="c1">#     if (method == &quot;inversion&quot;):</span>
<span class="c1">#         loader = DataLoader(dataset=dataset, batch_size=1,</span>
<span class="c1">#                             shuffle=False)</span>
<span class="c1">#         for data in loader:</span>

<span class="c1">#             (output_coord, model_raw_output, out_monitor), (phix, phiy) = model(data.to(device))</span>

<span class="c1">#             # Compute the new mesh coord given model output phi</span>
<span class="c1">#             bs = 1</span>
<span class="c1">#             feat_dim = data.mesh_feat.shape[-1]</span>
<span class="c1">#             # mesh_feat [coord_x, coord_y, u, hessian_norm]</span>
<span class="c1">#             node_num = data.mesh_feat.view(bs, -1, feat_dim).shape[1]</span>

<span class="c1">#             out_area = get_face_area(output_coord, data.face)</span>
<span class="c1">#             in_area = get_face_area(data.x[:, :2], data.face)</span>
<span class="c1">#             # restore the sign of the area</span>
<span class="c1">#             out_area = torch.sign(in_area) * out_area</span>
<span class="c1">#             # mask for negative area</span>
<span class="c1">#             neg_mask = out_area &lt; 0</span>
<span class="c1">#             neg_area = out_area[neg_mask]</span>
<span class="c1">#             # calculate the loss, we want it normalized by the batch size</span>
<span class="c1">#             # and loss should be positive, so we are using -1 here.</span>
<span class="c1">#             num_tangle += len(neg_area)</span>
<span class="c1">#         return num_tangle / len(dataset)</span>

<span class="c1">#     # deprecated, do not use this option unless you know what you are doing</span>
<span class="c1">#     elif (method == &quot;msg&quot;):</span>
<span class="c1">#         for i in range(len(dataset)):</span>
<span class="c1">#             data = dataset[i].to(device)</span>
<span class="c1">#             with torch.no_grad():</span>
<span class="c1">#                 output_data = model(data)</span>
<span class="c1">#                 input_edge = data.edge_index</span>
<span class="c1">#                 mesh = data.x[:, :2]</span>
<span class="c1">#                 mesh_new = output_data</span>
<span class="c1">#                 Counter = TangleCounter()</span>
<span class="c1">#                 num_tangle += Counter(mesh, mesh_new, input_edge).item()</span>
<span class="c1">#         num_tangle = num_tangle / len(dataset)</span>
<span class="c1">#         return num_tangle</span>


<span class="k">def</span> <span class="nf">print_parameter_grad</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;param name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">, grad: </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;param name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">, grad is None!&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="train">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.train">[docs]</a>
<span class="k">def</span> <span class="nf">train</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">,</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">,</span>
    <span class="n">device</span><span class="p">,</span>
    <span class="n">loss_func</span><span class="p">,</span>
    <span class="n">use_jacob</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_diff_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_area_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">weight_deform_loss</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">weight_area_loss</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">weight_chamfer_loss</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trains a PyTorch model using the given data loader, optimizer,</span>
<span class="sd">        and loss function.</span>

<span class="sd">    Args:</span>
<span class="sd">        loader (DataLoader): DataLoader object for the training data.</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model to train.</span>
<span class="sd">        optimizer (Optimizer): The optimizer (e.g., Adam, SGD).</span>
<span class="sd">        device (torch.device): The device to run the computation on.</span>
<span class="sd">        loss_func (callable): Loss function (e.g., MSE, Cross-Entropy).</span>
<span class="sd">        use_jacob (bool): Whether or not to use Jacobian loss.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The average training loss across all batches.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">batch_size</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_area_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_chamfer_loss</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">loader</span><span class="p">:</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">area_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># deformation loss</span>
        <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">loss_func</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_jacob</span>
            <span class="k">else</span> <span class="n">jacobLoss</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Inversion loss</span>
        <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
            <span class="n">inversion_loss</span> <span class="o">=</span> <span class="n">get_inversion_loss</span><span class="p">(</span>
                <span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_area_loss</span><span class="p">:</span>
            <span class="n">area_loss</span> <span class="o">=</span> <span class="n">get_area_loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span><span class="p">)</span>

        <span class="n">chamfer_loss</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">chamfer_distance</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">weight_deform_loss</span> <span class="o">*</span> <span class="n">deform_loss</span>
            <span class="o">+</span> <span class="n">inversion_loss</span>
            <span class="o">+</span> <span class="n">inversion_diff_loss</span>
            <span class="o">+</span> <span class="n">weight_area_loss</span> <span class="o">*</span> <span class="n">area_loss</span>
            <span class="o">+</span> <span class="n">weight_chamfer_loss</span> <span class="o">*</span> <span class="n">chamfer_loss</span>
        <span class="p">)</span>
        <span class="c1"># Jacobian loss</span>
        <span class="k">if</span> <span class="n">use_jacob</span><span class="p">:</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="c1"># print_parameter_grad(model)</span>

        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_deform_loss</span> <span class="o">+=</span> <span class="n">weight_deform_loss</span> <span class="o">*</span> <span class="n">deform_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_inversion_loss</span> <span class="o">+=</span> <span class="n">inversion_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_loss</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># noqa</span>
        <span class="n">total_inversion_diff_loss</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">inversion_diff_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_diff_loss</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>  <span class="c1"># noqa</span>
        <span class="n">total_area_loss</span> <span class="o">+=</span> <span class="n">weight_area_loss</span> <span class="o">*</span> <span class="n">area_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_area_loss</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">total_chamfer_loss</span> <span class="o">+=</span> <span class="n">weight_chamfer_loss</span> <span class="o">*</span> <span class="n">chamfer_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;total_loss&quot;</span><span class="p">:</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
        <span class="s2">&quot;deform_loss&quot;</span><span class="p">:</span> <span class="n">total_deform_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_inversion_diff_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_diff_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_diff_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_area_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;area_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_area_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;chamfer_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_chamfer_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="evaluate">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.evaluate">[docs]</a>
<span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">,</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">device</span><span class="p">,</span>
    <span class="n">loss_func</span><span class="p">,</span>
    <span class="n">use_jacob</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_diff_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_area_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">weight_deform_loss</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">weight_area_loss</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">weight_chamfer_loss</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates a model using the given data loader and loss function.</span>

<span class="sd">    Args:</span>
<span class="sd">        loader (DataLoader): DataLoader object for the evaluation data.</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model to evaluate.</span>
<span class="sd">        device (torch.device): The device to run the computation on.</span>
<span class="sd">        loss_func (callable): Loss function (e.g., MSE, Cross-Entropy).</span>
<span class="sd">        use_jacob (bool): Whether or not to use Jacobian loss. Defaults to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The average evaluation loss across all batches.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">batch_size</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_area_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_chamfer_loss</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">loader</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">area_loss</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">loss_func</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">use_jacob</span>
                <span class="k">else</span> <span class="n">jacobLoss</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
                <span class="n">inversion_loss</span> <span class="o">=</span> <span class="n">get_inversion_loss</span><span class="p">(</span>
                    <span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">use_area_loss</span><span class="p">:</span>
                <span class="n">area_loss</span> <span class="o">=</span> <span class="n">get_area_loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span><span class="p">)</span>

            <span class="n">chamfer_loss</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">100</span> <span class="o">*</span> <span class="n">chamfer_distance</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">weight_deform_loss</span> <span class="o">*</span> <span class="n">deform_loss</span>
                <span class="o">+</span> <span class="n">inversion_loss</span>
                <span class="o">+</span> <span class="n">inversion_diff_loss</span>
                <span class="o">+</span> <span class="n">weight_area_loss</span> <span class="o">*</span> <span class="n">area_loss</span>
                <span class="o">+</span> <span class="n">weight_chamfer_loss</span> <span class="o">*</span> <span class="n">chamfer_loss</span>
            <span class="p">)</span>
            <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">total_deform_loss</span> <span class="o">+=</span> <span class="n">weight_deform_loss</span> <span class="o">*</span> <span class="n">deform_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">total_inversion_diff_loss</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">inversion_diff_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_diff_loss</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="p">)</span>  <span class="c1"># noqa</span>
            <span class="n">total_inversion_loss</span> <span class="o">+=</span> <span class="n">inversion_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_loss</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># noqa</span>
            <span class="n">total_area_loss</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">weight_area_loss</span> <span class="o">*</span> <span class="n">area_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_area_loss</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">total_chamfer_loss</span> <span class="o">+=</span> <span class="n">weight_chamfer_loss</span> <span class="o">*</span> <span class="n">chamfer_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;total_loss&quot;</span><span class="p">:</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
        <span class="s2">&quot;deform_loss&quot;</span><span class="p">:</span> <span class="n">total_deform_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_inversion_diff_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_diff_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_diff_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_area_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;area_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_area_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;chamfer_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_chamfer_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>



<span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ori_mesh_x</span><span class="p">,</span> <span class="n">ori_mesh_y</span><span class="p">,</span> <span class="n">moved_x</span><span class="p">,</span> <span class="n">moved_y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    u: [bs, node_num, 1]</span>
<span class="sd">    ori_mesh_x: [bs, node_num, 1]</span>
<span class="sd">    ori_mesh_y: [bs, node_num, 1]</span>
<span class="sd">    moved_x: [bs, node_num, 1]</span>
<span class="sd">    moved_y: [bs, node_num, 1]</span>

<span class="sd">    Note: node_num equals to sample_num</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sample_num</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print(f&quot;batch size: {batch_size}, sample num: {sample_num}&quot;)</span>
    <span class="n">u_interpolateds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
        <span class="c1"># For a sample point of interest, we need to do a weighted summation over all other sample points</span>
        <span class="c1"># To avoid using a loop, we expand an additonal dim of size sample_num</span>
        <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">ori_mesh_x</span><span class="p">[</span><span class="n">bs</span><span class="p">],</span> <span class="n">ori_mesh_y</span><span class="p">[</span><span class="n">bs</span><span class="p">]),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">moved_mesh</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">moved_x</span><span class="p">[</span><span class="n">bs</span><span class="p">],</span> <span class="n">moved_y</span><span class="p">[</span><span class="n">bs</span><span class="p">]),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sample_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># print(f&quot;new mesh shape {moved_mesh.shape}, original mesh shape {original_mesh.shape}&quot;)</span>
        <span class="c1"># print((moved_mesh - original_mesh),(moved_mesh - original_mesh).shape)</span>
        <span class="c1"># print(&quot;check dimension &quot;, (moved_mesh - original_mesh)[:, 0])</span>

        <span class="c1"># The second dimension of distance is the different sample points</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">moved_mesh</span> <span class="o">-</span> <span class="n">original_mesh</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sample_num</span><span class="p">)</span>
        <span class="c1"># print(&#39;raw distance &#39;, torch.norm(moved_mesh - original_mesh, dim=-1))</span>
        <span class="c1"># print(&#39;distance &#39;, torch.norm(moved_mesh - original_mesh, dim=-1)* np.sqrt(sample_num))</span>
        <span class="n">normalize</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="c1"># print(&#39;weight shape &#39;, weight.shape, u[bs].shape)</span>
        <span class="c1"># print(&#39;weight &#39;, weight, u, u[bs].permute(1, 0) * weight)</span>
        <span class="c1"># print(u.shape, weight.shape)</span>
        <span class="n">u_interpolateds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">bs</span><span class="p">]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># print(f&quot;interpolated shape: {u_interpolateds[-1]}&quot;)</span>
        <span class="c1"># print(&#39;inte &#39;, u_interpolated)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">u_interpolateds</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_generate_samples</span><span class="p">(</span>
    <span class="n">num_meshes</span><span class="p">,</span>
    <span class="n">num_samples_per_mesh</span><span class="p">,</span>
    <span class="n">coords</span><span class="p">,</span>
    <span class="n">solution</span><span class="p">,</span>
    <span class="n">monitor</span><span class="p">,</span>
    <span class="n">redundant_sample_ratio</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">meshes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="n">redundant_sample_ratio</span> <span class="o">*</span> <span class="n">num_samples_per_mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">solution_input</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">monitor_input</span> <span class="o">=</span> <span class="n">monitor</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">coords_x</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">coords_y</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">new_meshes_x</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_meshes_y</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">solutions</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span>
        <span class="n">solution_input</span><span class="p">,</span> <span class="n">coords_x</span><span class="p">,</span> <span class="n">coords_y</span><span class="p">,</span> <span class="n">new_meshes_x</span><span class="p">,</span> <span class="n">new_meshes_y</span>
    <span class="p">)</span>
    <span class="n">monitors</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span>
        <span class="n">monitor_input</span><span class="p">,</span> <span class="n">coords_x</span><span class="p">,</span> <span class="n">coords_y</span><span class="p">,</span> <span class="n">new_meshes_x</span><span class="p">,</span> <span class="n">new_meshes_y</span>
    <span class="p">)</span>

    <span class="n">meshes_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">soluitons_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">monitors_</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># resample according to the monitor values</span>
    <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">monitors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">monitors</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">monitors</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">a</span><span class="o">=</span><span class="n">meshes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">size</span><span class="o">=</span><span class="n">num_samples_per_mesh</span><span class="p">,</span>
            <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">prob</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="c1"># print(torch.max(prob), torch.min(prob), torch.max(monitors), torch.min(monitors))</span>
        <span class="n">meshes_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshes</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">soluitons_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solutions</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">monitors_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">monitors</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:])</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">meshes_</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">soluitons_</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">monitors_</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">generate_samples</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">num_samples_per_mesh</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_meshes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
    <span class="c1"># num_meshes = 5</span>
    <span class="c1"># num_nodes = coord_ori.shape[-2] // bs</span>
    <span class="c1"># samples_q = data.mesh_feat[:, :4].view(bs, -1, 4)</span>
    <span class="n">meshes_collection</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">solutions_collection</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">monitors_collection</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bs</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="n">b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="n">b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">monitor</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="n">b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">meshes</span><span class="p">,</span> <span class="n">solutions</span><span class="p">,</span> <span class="n">monitors</span> <span class="o">=</span> <span class="n">_generate_samples</span><span class="p">(</span>
            <span class="n">num_meshes</span><span class="o">=</span><span class="n">num_meshes</span><span class="p">,</span>
            <span class="n">num_samples_per_mesh</span><span class="o">=</span><span class="n">num_samples_per_mesh</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">solution</span><span class="o">=</span><span class="n">solution</span><span class="p">,</span>
            <span class="n">monitor</span><span class="o">=</span><span class="n">monitor</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># print(f&quot;output meshes: {meshes.shape} solutions: {solutions.shape} monitor: {monitors.shape}&quot;)</span>
        <span class="c1"># merge the addtional sampled attributes (mesh, solution, monitor) to a large graph within one sample</span>
        <span class="n">meshes_collection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">coords</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">meshes</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">solutions_collection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">solution</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">solutions</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">monitors_collection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">monitor</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">monitors</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># merge all enhanced sampled samples along the batch size dimension</span>
    <span class="n">meshes_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">meshes_collection</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">solutions_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">solutions_collection</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">monitors_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">monitors_collection</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># merge all batched sampled attributes along feature dim for transformer key and value</span>
    <span class="n">samples_kv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">meshes_input</span><span class="p">,</span> <span class="n">solutions_input</span><span class="p">,</span> <span class="n">monitors_input</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples_kv</span>


<span class="k">def</span> <span class="nf">compute_finite_difference</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
    <span class="c1"># Field: [bs, x_shape, y_shape]</span>
    <span class="n">f_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">f_x</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">f_x</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">f_x</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">f_y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">f_y</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">f_y</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_y</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">inv_dx</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">inv_dy</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">f_x</span> <span class="o">*</span> <span class="n">inv_dx</span><span class="p">,</span> <span class="n">f_y</span> <span class="o">*</span> <span class="n">inv_dy</span>


<span class="k">def</span> <span class="nf">generate_samples_structured_grid</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">grid_resolution</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
    <span class="n">num_meshes</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">grid_resolution</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">grid_resolution</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
    <span class="n">uniform_grid</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">field_input</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">coords_x</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">coords_y</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_meshes_x</span> <span class="o">=</span> <span class="n">uniform_grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_meshes_y</span> <span class="o">=</span> <span class="n">uniform_grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Interpolate to dense structured grid</span>
    <span class="n">field</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">field_input</span><span class="p">,</span> <span class="n">coords_x</span><span class="p">,</span> <span class="n">coords_y</span><span class="p">,</span> <span class="n">new_meshes_x</span><span class="p">,</span> <span class="n">new_meshes_y</span><span class="p">)</span>
    <span class="n">field_x_</span><span class="p">,</span> <span class="n">field_y_</span> <span class="o">=</span> <span class="n">compute_finite_difference</span><span class="p">(</span>
        <span class="n">field</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid_resolution</span><span class="p">,</span> <span class="n">grid_resolution</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">field_x_</span> <span class="o">=</span> <span class="n">field_x_</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">field_y_</span> <span class="o">=</span> <span class="n">field_y_</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">num_meshes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Interpolate back to original mesh</span>
    <span class="n">field_x</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">field_x_</span><span class="p">,</span> <span class="n">new_meshes_x</span><span class="p">,</span> <span class="n">new_meshes_y</span><span class="p">,</span> <span class="n">coords_x</span><span class="p">,</span> <span class="n">coords_y</span><span class="p">)</span>
    <span class="n">field_y</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">field_y_</span><span class="p">,</span> <span class="n">new_meshes_x</span><span class="p">,</span> <span class="n">new_meshes_y</span><span class="p">,</span> <span class="n">coords_x</span><span class="p">,</span> <span class="n">coords_y</span><span class="p">)</span>
    <span class="c1"># print(f&quot;coords shape {coords.shape} interp field x {field_x.shape} interp field y {field_y.shape}&quot;)</span>

    <span class="k">return</span> <span class="n">uniform_grid</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">field_x_</span><span class="p">,</span> <span class="n">field_y_</span><span class="p">,</span> <span class="n">field_x</span><span class="p">,</span> <span class="n">field_y</span>


<span class="k">def</span> <span class="nf">construct_graph</span><span class="p">(</span><span class="n">sampled_coords</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">sampled_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_per_mesh</span> <span class="o">=</span> <span class="n">sampled_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bs</span><span class="p">)])</span>
        <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_per_mesh</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">edge_index</span> <span class="o">=</span> <span class="n">knn_graph</span><span class="p">(</span>
        <span class="n">sampled_coords</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="n">batch</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">edge_index</span>


<span class="k">def</span> <span class="nf">compute_phi_hessian</span><span class="p">(</span>
    <span class="n">mesh_query_x</span><span class="p">,</span>
    <span class="n">mesh_query_y</span><span class="p">,</span>
    <span class="n">phix</span><span class="p">,</span>
    <span class="n">phiy</span><span class="p">,</span>
    <span class="n">out_monitor</span><span class="p">,</span>
    <span class="n">bs</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">loss_func</span><span class="p">,</span>
    <span class="n">finite_difference_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">feat_dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">node_num</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">feat_dim</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sampled_num</span> <span class="o">=</span> <span class="n">mesh_query_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">bs</span>
    <span class="n">sampled_ratio</span> <span class="o">=</span> <span class="n">sampled_num</span> <span class="o">//</span> <span class="n">node_num</span>

    <span class="c1"># equation residual loss</span>
    <span class="n">loss_eq_residual</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="c1"># Convex loss</span>
    <span class="n">loss_convex</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">phix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">phiy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">finite_difference_grad</span><span class="p">:</span>
            <span class="c1"># print(f&quot;phix: {phix.shape}, phiy: {phiy.shape}&quot;)</span>
            <span class="n">hessian_seed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">phix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="n">phixx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
                <span class="n">phix</span><span class="p">,</span>
                <span class="n">mesh_query_x</span><span class="p">,</span>
                <span class="n">grad_outputs</span><span class="o">=</span><span class="n">hessian_seed</span><span class="p">,</span>
                <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">allow_unused</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">phixy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
                <span class="n">phix</span><span class="p">,</span>
                <span class="n">mesh_query_y</span><span class="p">,</span>
                <span class="n">grad_outputs</span><span class="o">=</span><span class="n">hessian_seed</span><span class="p">,</span>
                <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">allow_unused</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">phiyx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
                <span class="n">phiy</span><span class="p">,</span>
                <span class="n">mesh_query_x</span><span class="p">,</span>
                <span class="n">grad_outputs</span><span class="o">=</span><span class="n">hessian_seed</span><span class="p">,</span>
                <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">allow_unused</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">phiyy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
                <span class="n">phiy</span><span class="p">,</span>
                <span class="n">mesh_query_y</span><span class="p">,</span>
                <span class="n">grad_outputs</span><span class="o">=</span><span class="n">hessian_seed</span><span class="p">,</span>
                <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">allow_unused</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: the finite difference method here returns the (u_y, u_x), whose order is different from ad</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">phixy</span><span class="p">,</span> <span class="n">phixx</span> <span class="o">=</span> <span class="n">generate_samples_structured_grid</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">mesh_query_x</span><span class="p">,</span> <span class="n">mesh_query_y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">phix</span>
            <span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">phiyy</span><span class="p">,</span> <span class="n">phiyx</span> <span class="o">=</span> <span class="n">generate_samples_structured_grid</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">mesh_query_x</span><span class="p">,</span> <span class="n">mesh_query_y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">phiy</span>
            <span class="p">)</span>
        <span class="c1"># print(f&quot;phix grad: {phix_grad.shape}, phiy grad: {phiy_grad.shape}&quot;)</span>
        <span class="c1"># phixx = phix_grad[:, 0]</span>
        <span class="c1"># phixy = phix_grad[:, 1]</span>
        <span class="c1"># phiyx = phiy_grad[:, 0]</span>
        <span class="c1"># phiyy = phiy_grad[:, 1]</span>
        <span class="c1"># print(f&quot;phixx grad: {torch.sum(phixx)}, phixy grad: {torch.sum(phixy)}, phiyx grad: {torch.sum(phiyx)}, phiyy grad: {torch.sum(phiyy)}&quot;)</span>
        <span class="n">det_hessian</span> <span class="o">=</span> <span class="p">(</span><span class="n">phixx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">phiyy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">phixy</span> <span class="o">*</span> <span class="n">phiyx</span>
        <span class="n">det_hessian</span> <span class="o">=</span> <span class="n">det_hessian</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">sampled_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># jacobian_x = data.mesh_feat[:, 4].view(bs, node_num, 1)</span>
        <span class="c1"># jacobian_y = data.mesh_feat[:, 5].view(bs, node_num, 1)</span>

        <span class="n">hessian_norm</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sampled_ratio</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># solution = data.mesh_feat[:, 1].resahpe(bs, node_num, 1)</span>
        <span class="c1"># original_mesh_x = data.mesh_feat[:, 0].view(bs, node_num, 1)</span>
        <span class="c1"># original_mesh_y = data.mesh_feat[:, 1].view(bs, node_num, 1)</span>

        <span class="n">moved_x</span> <span class="o">=</span> <span class="n">phix</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">sampled_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">mesh_query_x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">sampled_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">moved_y</span> <span class="o">=</span> <span class="n">phiy</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">sampled_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">mesh_query_y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">sampled_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># print(f&quot;diff x:{torch.abs(original_mesh_x - moved_x).mean()}, diff y:{torch.abs(original_mesh_y - moved_y).mean()}&quot;)</span>
        <span class="c1"># Interpolate on new moved mesh</span>
        <span class="c1"># print(hessian_norm.shape, mesh_query_x.shape, moved_x.shape)</span>
        <span class="n">hessian_norm_</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span>
            <span class="n">hessian_norm</span><span class="p">,</span>
            <span class="n">mesh_query_x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">sampled_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">mesh_query_y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">sampled_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">moved_x</span><span class="p">,</span>
            <span class="n">moved_y</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">enhanced_hessian_norm</span> <span class="o">=</span> <span class="n">hessian_norm_</span>  <span class="c1"># + out_monitor.view(bs, node_num, 1)</span>

        <span class="c1"># =========================== jacobian related attempts ==================</span>
        <span class="c1"># jac_x = interpolate(jacobian_x, original_mesh_x, original_mesh_y, moved_x, moved_y)</span>
        <span class="c1"># jac_y = interpolate(jacobian_y, original_mesh_x, original_mesh_y, moved_x, moved_y)</span>
        <span class="c1"># # alpha = torch.sum(torch.sqrt(torch.abs(jac_x)**2 + torch.abs(jac_y)**2), dim=(-1, -2)) / node_num**2</span>
        <span class="c1"># alpha = 1.0</span>

        <span class="c1"># phixx = phixx.reshape(bs, node_num, 1)</span>
        <span class="c1"># phiyx = phiyx.reshape(bs, node_num, 1)</span>
        <span class="c1"># phiyy = phiyy.reshape(bs, node_num, 1)</span>
        <span class="c1"># phixy = phixy.reshape(bs, node_num, 1)</span>

        <span class="c1"># jac_xi_1 = jac_x * (1 + phixx) + jac_y * phiyx</span>
        <span class="c1"># jac_xi_2 = jac_x * phixy + jac_y * (1 + phiyy)</span>
        <span class="c1"># print(torch.sum(jac_xi_1), torch.sum(jac_xi_2))</span>
        <span class="c1"># monitor = monitor_grad(alpha, jac_xi_1, jac_xi_2) /1000</span>
        <span class="c1"># ===========================</span>

        <span class="c1"># TODO: here the 1 + 5 * heesian_norm is the monitor function used when generating dataset</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">enhanced_hessian_norm</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_hessian</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hessian_norm</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">sampled_num</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sampled_num</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">loss_eq_residual</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="c1"># print(torch.sum(hessian_norm_ - hessian_norm), hessian_norm_.shape, det_hessian.shape, lhs.shape, rhs.shape)</span>
        <span class="c1"># print(f&quot;diff between interpolation jac x {torch.sum(jacobian_x - jac_x)} alpha: {alpha} monitor: {torch.sum(monitor)} det_hessian {torch.sum(det_hessian)} lhs {torch.sum(lhs)} rhs {torch.sum(rhs)}&quot;)</span>

        <span class="c1"># Convex loss</span>
        <span class="c1"># if use_convex_loss:</span>
        <span class="n">loss_convex</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">type_as</span><span class="p">(</span><span class="n">phixx</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">phixx</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">type_as</span><span class="p">(</span><span class="n">phiyy</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">phiyy</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">loss_eq_residual</span><span class="p">,</span>
            <span class="n">loss_convex</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">model_forward</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">use_add_random_query</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># Create mesh query for deformer, seperate from the original mesh as feature for encoder</span>
    <span class="n">mesh_query_x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">mesh_query_y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">mesh_query_x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">mesh_query_y</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">mesh_query</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">mesh_query_x</span><span class="p">,</span> <span class="n">mesh_query_y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">mesh_query</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">//</span> <span class="n">bs</span>

    <span class="n">coord_ori_x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">coord_ori_y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">coord_ori_x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">coord_ori_y</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">coord_ori</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">coord_ori_x</span><span class="p">,</span> <span class="n">coord_ori_y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_add_random_query</span><span class="p">:</span>
        <span class="c1"># Generate random mesh queries for unsupervised learning</span>
        <span class="n">sampled_queries</span> <span class="o">=</span> <span class="n">generate_samples</span><span class="p">(</span>
            <span class="n">bs</span><span class="o">=</span><span class="n">bs</span><span class="p">,</span>
            <span class="n">num_samples_per_mesh</span><span class="o">=</span><span class="n">num_nodes</span><span class="p">,</span>
            <span class="n">num_meshes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sampled_queries_edge_index</span> <span class="o">=</span> <span class="n">construct_graph</span><span class="p">(</span>
            <span class="n">sampled_queries</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">6</span>
        <span class="p">)</span>

        <span class="n">mesh_sampled_queries_x</span> <span class="o">=</span> <span class="n">sampled_queries</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="n">mesh_sampled_queries_y</span> <span class="o">=</span> <span class="n">sampled_queries</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="n">mesh_sampled_queries_x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mesh_sampled_queries_y</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mesh_sampled_queries</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">mesh_sampled_queries_x</span><span class="p">,</span> <span class="n">mesh_sampled_queries_y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">coord_ori</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">//</span> <span class="n">bs</span>
        <span class="c1"># input_kv = generate_samples(</span>
        <span class="c1">#     bs=bs, num_samples_per_mesh=num_nodes, data=data, device=device</span>
        <span class="c1"># )</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_sampled_queries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># input_kv = None</span>
        <span class="n">sampled_queries_edge_index</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># input_q = data.mesh_feat[:, :4]</span>
    <span class="n">input_q</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span>

    <span class="c1"># print(f&quot;batch size: {bs}, num_nodes: {num_nodes}, input q&quot;, input_q.shape, &quot;input_kv &quot;, input_kv.shape)</span>

    <span class="c1"># if not use_add_random_query:</span>
    <span class="c1">#     mesh_sampled_queries = None</span>
    <span class="c1">#     sampled_queries_edge_index = None</span>

    <span class="p">(</span><span class="n">output_coord_all</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">out_monitor</span><span class="p">),</span> <span class="p">(</span><span class="n">phix</span><span class="p">,</span> <span class="n">phiy</span><span class="p">)</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">input_q</span><span class="p">,</span>
        <span class="n">input_q</span><span class="p">,</span>
        <span class="n">mesh_query</span><span class="p">,</span>
        <span class="n">mesh_sampled_queries</span><span class="p">,</span>
        <span class="n">sampled_queries_edge_index</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_add_random_query</span><span class="p">:</span>
        <span class="n">phix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">phiy</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># (output_coord_all, output, out_monitor), (phix, phiy) = model(data, input_q, input_kv, mesh_query, sampled_queries, sampled_queries_edge_index)</span>
    <span class="n">output_coord</span> <span class="o">=</span> <span class="n">output_coord_all</span><span class="p">[:</span> <span class="n">num_nodes</span> <span class="o">*</span> <span class="n">bs</span><span class="p">]</span>
    <span class="c1"># print(output_coord_all.shape, output_coord.shape)</span>

    <span class="c1"># mesh_query_x_all = torch.cat([mesh_query_x, mesh_sampled_queries[:, :, 0].view(-1, 1)], dim=0)</span>
    <span class="c1"># mesh_query_y_all = torch.cat([mesh_query_y, mesh_sampled_queries[:, :, 1].view(-1, 1)], dim=0)</span>
    <span class="k">if</span> <span class="n">use_add_random_query</span><span class="p">:</span>
        <span class="n">mesh_query_x_all</span> <span class="o">=</span> <span class="n">mesh_sampled_queries_x</span>
        <span class="n">mesh_query_y_all</span> <span class="o">=</span> <span class="n">mesh_sampled_queries_y</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_query_x_all</span> <span class="o">=</span> <span class="n">mesh_query_x</span>
        <span class="n">mesh_query_y_all</span> <span class="o">=</span> <span class="n">mesh_query_y</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">output_coord</span><span class="p">,</span>
        <span class="n">output</span><span class="p">,</span>
        <span class="n">out_monitor</span><span class="p">,</span>
        <span class="n">phix</span><span class="p">,</span>
        <span class="n">phiy</span><span class="p">,</span>
        <span class="n">mesh_query_x_all</span><span class="p">,</span>
        <span class="n">mesh_query_y_all</span><span class="p">,</span>
    <span class="p">)</span>


<span class="c1"># def chamfer_distance(mesh_test, mesh_target):</span>
<span class="c1">#     # (batch, node, feature)</span>
<span class="c1">#     batch_size = mesh_test.shape[0]</span>
<span class="c1">#     node_num = mesh_test.shape[1]</span>

<span class="c1">#     chamfer_distance_val = 0.0</span>
<span class="c1">#     for bs in range(batch_size):</span>
<span class="c1">#         mesh_stack = mesh_test[bs].unsqueeze(-2).repeat(1, node_num, 1)</span>
<span class="c1">#         # print(&quot;output mesh &quot;, mesh_stack.shape)</span>
<span class="c1">#         # diff shape: (distance of a node in mesh_test to every node of mesh_target , number of node, feature)</span>
<span class="c1">#         diff = torch.norm(mesh_stack - mesh_target[bs], dim=-1)</span>
<span class="c1">#         min_diff = torch.min(diff, dim=0)</span>
<span class="c1">#         # min_diff[0] values, min_diff[1] index</span>
<span class="c1">#         min_diff_sum = torch.sum(min_diff[0])</span>
<span class="c1">#         chamfer_distance_val += min_diff_sum / node_num</span>
<span class="c1">#         # diff = mesh_stack - mesh_target[bs]</span>
<span class="c1">#         # print(diff, diff[0])</span>
<span class="c1">#         # print(&quot;min diff &quot;, min_diff)</span>
<span class="c1">#     return chamfer_distance_val / batch_size</span>


<span class="k">def</span> <span class="nf">sample_nodes_by_monitor</span><span class="p">(</span>
    <span class="n">meshes</span><span class="p">,</span> <span class="n">meshes_target</span><span class="p">,</span> <span class="n">monitors</span><span class="p">,</span> <span class="n">num_samples_per_mesh</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">666</span>
<span class="p">):</span>
    <span class="c1"># Set random seed</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="c1"># resample according to the monitor values</span>
    <span class="n">meshes_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshes_target_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">monitors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">monitors</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">monitors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">monitors</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">monitors</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">a</span><span class="o">=</span><span class="n">meshes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">size</span><span class="o">=</span><span class="n">num_samples_per_mesh</span><span class="p">,</span>
            <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">prob</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="c1"># print(torch.max(prob), torch.min(prob), torch.max(monitors), torch.min(monitors))</span>
        <span class="n">meshes_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshes</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">meshes_target_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshes_target</span><span class="p">[</span><span class="n">bs</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">test_meshes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">meshes_</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">target_meshes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">meshes_target_</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">test_meshes</span><span class="p">,</span> <span class="n">target_meshes</span>


<div class="viewcode-block" id="train_unsupervised">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.train_unsupervised">[docs]</a>
<span class="k">def</span> <span class="nf">train_unsupervised</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">,</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">,</span>
    <span class="n">device</span><span class="p">,</span>
    <span class="n">loss_func</span><span class="p">,</span>
    <span class="n">use_jacob</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_diff_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_area_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_convex_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_add_random_query</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">finite_difference_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">weight_area_loss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">weight_deform_loss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">weight_chamfer_loss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">weight_eq_residual_loss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trains a PyTorch model using the given data loader, optimizer,</span>
<span class="sd">        and loss function.</span>

<span class="sd">    Args:</span>
<span class="sd">        loader (DataLoader): DataLoader object for the training data.</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model to train.</span>
<span class="sd">        optimizer (Optimizer): The optimizer (e.g., Adam, SGD).</span>
<span class="sd">        device (torch.device): The device to run the computation on.</span>
<span class="sd">        loss_func (callable): Loss function (e.g., MSE, Cross-Entropy).</span>
<span class="sd">        use_jacob (bool): Whether or not to use Jacobian loss.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The average training loss across all batches.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">batch_size</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_eq_residual_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_convex_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_area_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_chamfer_loss_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">loader</span><span class="p">:</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="n">output_coord</span><span class="p">,</span>
            <span class="n">output</span><span class="p">,</span>
            <span class="n">out_monitor</span><span class="p">,</span>
            <span class="n">phix</span><span class="p">,</span>
            <span class="n">phiy</span><span class="p">,</span>
            <span class="n">mesh_query_x_all</span><span class="p">,</span>
            <span class="n">mesh_query_y_all</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">model_forward</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">use_add_random_query</span><span class="o">=</span><span class="n">use_add_random_query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_add_random_query</span><span class="p">:</span>
            <span class="n">loss_eq_residual</span><span class="p">,</span> <span class="n">loss_convex</span> <span class="o">=</span> <span class="n">compute_phi_hessian</span><span class="p">(</span>
                <span class="n">mesh_query_x_all</span><span class="p">,</span>
                <span class="n">mesh_query_y_all</span><span class="p">,</span>
                <span class="n">phix</span><span class="p">,</span>
                <span class="n">phiy</span><span class="p">,</span>
                <span class="n">out_monitor</span><span class="p">,</span>
                <span class="n">bs</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">loss_func</span><span class="o">=</span><span class="n">loss_func</span><span class="p">,</span>
                <span class="n">finite_difference_grad</span><span class="o">=</span><span class="n">finite_difference_grad</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss_eq_residual</span><span class="p">,</span> <span class="n">loss_convex</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_convex_loss</span><span class="p">:</span>
            <span class="n">loss_convex</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">deform_loss</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">area_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># deformation loss</span>
        <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">loss_func</span><span class="p">(</span><span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_jacob</span>
            <span class="k">else</span> <span class="n">jacobLoss</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Chamfer loss</span>
        <span class="n">coord_dim</span> <span class="o">=</span> <span class="n">output_coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Sampling according to monitor values, sampled 100 nodes per mesh</span>
        <span class="n">mesh_test_raw</span> <span class="o">=</span> <span class="n">output_coord</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coord_dim</span><span class="p">)</span>
        <span class="n">mesh_target_raw</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coord_dim</span><span class="p">)</span>
        <span class="n">monitors</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mesh_test_sampled</span><span class="p">,</span> <span class="n">mesh_target_sampled</span> <span class="o">=</span> <span class="n">sample_nodes_by_monitor</span><span class="p">(</span>
            <span class="n">meshes</span><span class="o">=</span><span class="n">mesh_test_raw</span><span class="p">,</span> <span class="n">meshes_target</span><span class="o">=</span><span class="n">mesh_target_raw</span><span class="p">,</span> <span class="n">monitors</span><span class="o">=</span><span class="n">monitors</span>
        <span class="p">)</span>
        <span class="c1"># chamfer_loss = 100 * (chamfer_distance(mesh_test_sampled, mesh_target_sampled) + chamfer_distance(mesh_target_sampled, mesh_test_sampled))</span>
        <span class="n">chamfer_loss</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">100</span> <span class="o">*</span> <span class="n">chamfer_distance</span><span class="p">(</span><span class="n">output_coord</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># print(output_coord.shape, data.y.shape, chamfer_loss)</span>

        <span class="c1"># Inversion loss</span>
        <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
            <span class="n">inversion_loss</span> <span class="o">=</span> <span class="n">get_inversion_loss</span><span class="p">(</span>
                <span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler</span>
            <span class="p">)</span>

        <span class="c1"># if use_area_loss:</span>
        <span class="n">area_loss</span> <span class="o">=</span> <span class="n">get_area_loss</span><span class="p">(</span><span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">weight_deform_loss</span> <span class="o">*</span> <span class="n">deform_loss</span>
            <span class="o">+</span> <span class="n">weight_chamfer_loss</span> <span class="o">*</span> <span class="n">chamfer_loss</span>
            <span class="o">+</span> <span class="n">inversion_loss</span>
            <span class="o">+</span> <span class="n">inversion_diff_loss</span>
            <span class="o">+</span> <span class="n">weight_area_loss</span> <span class="o">*</span> <span class="n">area_loss</span>
            <span class="o">+</span> <span class="n">weight_eq_residual_loss</span> <span class="o">*</span> <span class="n">loss_eq_residual</span>
            <span class="o">+</span> <span class="n">loss_convex</span>
        <span class="p">)</span>

        <span class="c1"># Jacobian loss</span>
        <span class="k">if</span> <span class="n">use_jacob</span><span class="p">:</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="c1"># print_parameter_grad(model)</span>

        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_eq_residual_loss</span> <span class="o">+=</span> <span class="n">loss_eq_residual</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_convex_loss</span> <span class="o">+=</span> <span class="n">loss_convex</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_convex_loss</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">total_deform_loss</span> <span class="o">+=</span> <span class="n">weight_deform_loss</span> <span class="o">*</span> <span class="n">deform_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_chamfer_loss_loss</span> <span class="o">+=</span> <span class="n">weight_chamfer_loss</span> <span class="o">*</span> <span class="n">chamfer_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_inversion_loss</span> <span class="o">+=</span> <span class="n">inversion_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_loss</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># noqa</span>
        <span class="n">total_inversion_diff_loss</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">inversion_diff_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_diff_loss</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>  <span class="c1"># noqa</span>
        <span class="n">total_area_loss</span> <span class="o">+=</span> <span class="n">weight_area_loss</span> <span class="o">*</span> <span class="n">area_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;total_loss&quot;</span><span class="p">:</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
        <span class="s2">&quot;deform_loss&quot;</span><span class="p">:</span> <span class="n">total_deform_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
        <span class="s2">&quot;equation_residual&quot;</span><span class="p">:</span> <span class="n">total_eq_residual_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
        <span class="s2">&quot;chamfer_loss&quot;</span><span class="p">:</span> <span class="n">total_chamfer_loss_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">use_convex_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;convex_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_convex_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_inversion_diff_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_diff_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_diff_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_area_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;area_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_area_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="evaluate_unsupervised">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.evaluate_unsupervised">[docs]</a>
<span class="k">def</span> <span class="nf">evaluate_unsupervised</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">,</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">device</span><span class="p">,</span>
    <span class="n">loss_func</span><span class="p">,</span>
    <span class="n">use_jacob</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_diff_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_area_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_convex_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_add_random_query</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">finite_difference_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">weight_area_loss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">weight_deform_loss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">weight_eq_residual_loss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">weight_chamfer_loss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates a model using the given data loader and loss function.</span>

<span class="sd">    Args:</span>
<span class="sd">        loader (DataLoader): DataLoader object for the evaluation data.</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model to evaluate.</span>
<span class="sd">        device (torch.device): The device to run the computation on.</span>
<span class="sd">        loss_func (callable): Loss function (e.g., MSE, Cross-Entropy).</span>
<span class="sd">        use_jacob (bool): Whether or not to use Jacobian loss. Defaults to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The average evaluation loss across all batches.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">batch_size</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_eq_residual_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_convex_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_area_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_chamfer_loss_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">loader</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">area_loss</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># with torch.no_grad():</span>

        <span class="p">(</span>
            <span class="n">output_coord</span><span class="p">,</span>
            <span class="n">output</span><span class="p">,</span>
            <span class="n">out_monitor</span><span class="p">,</span>
            <span class="n">phix</span><span class="p">,</span>
            <span class="n">phiy</span><span class="p">,</span>
            <span class="n">mesh_query_x_all</span><span class="p">,</span>
            <span class="n">mesh_query_y_all</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">model_forward</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">use_add_random_query</span><span class="o">=</span><span class="n">use_add_random_query</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_add_random_query</span><span class="p">:</span>
            <span class="n">loss_eq_residual</span><span class="p">,</span> <span class="n">loss_convex</span> <span class="o">=</span> <span class="n">compute_phi_hessian</span><span class="p">(</span>
                <span class="n">mesh_query_x_all</span><span class="p">,</span>
                <span class="n">mesh_query_y_all</span><span class="p">,</span>
                <span class="n">phix</span><span class="p">,</span>
                <span class="n">phiy</span><span class="p">,</span>
                <span class="n">out_monitor</span><span class="p">,</span>
                <span class="n">bs</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">loss_func</span><span class="o">=</span><span class="n">loss_func</span><span class="p">,</span>
                <span class="n">finite_difference_grad</span><span class="o">=</span><span class="n">finite_difference_grad</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss_eq_residual</span><span class="p">,</span> <span class="n">loss_convex</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_convex_loss</span><span class="p">:</span>
            <span class="n">loss_convex</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">loss_func</span><span class="p">(</span><span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_jacob</span>
            <span class="k">else</span> <span class="n">jacobLoss</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
            <span class="n">inversion_loss</span> <span class="o">=</span> <span class="n">get_inversion_loss</span><span class="p">(</span>
                <span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler</span>
            <span class="p">)</span>
        <span class="c1"># if use_area_loss:</span>
        <span class="n">area_loss</span> <span class="o">=</span> <span class="n">get_area_loss</span><span class="p">(</span><span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span><span class="p">)</span>

        <span class="c1"># Chamfer loss</span>
        <span class="n">coord_dim</span> <span class="o">=</span> <span class="n">output_coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Sampling according to monitor values, sampled 100 nodes per mesh</span>
        <span class="n">mesh_test_raw</span> <span class="o">=</span> <span class="n">output_coord</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coord_dim</span><span class="p">)</span>
        <span class="n">mesh_target_raw</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">coord_dim</span><span class="p">)</span>
        <span class="n">monitors</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mesh_feat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mesh_test_sampled</span><span class="p">,</span> <span class="n">mesh_target_sampled</span> <span class="o">=</span> <span class="n">sample_nodes_by_monitor</span><span class="p">(</span>
            <span class="n">meshes</span><span class="o">=</span><span class="n">mesh_test_raw</span><span class="p">,</span> <span class="n">meshes_target</span><span class="o">=</span><span class="n">mesh_target_raw</span><span class="p">,</span> <span class="n">monitors</span><span class="o">=</span><span class="n">monitors</span>
        <span class="p">)</span>
        <span class="n">chamfer_loss</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">100</span> <span class="o">*</span> <span class="n">chamfer_distance</span><span class="p">(</span><span class="n">output_coord</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">weight_deform_loss</span> <span class="o">*</span> <span class="n">deform_loss</span>
            <span class="o">+</span> <span class="n">weight_chamfer_loss</span> <span class="o">*</span> <span class="n">chamfer_loss</span>
            <span class="o">+</span> <span class="n">inversion_loss</span>
            <span class="o">+</span> <span class="n">inversion_diff_loss</span>
            <span class="o">+</span> <span class="n">weight_area_loss</span> <span class="o">*</span> <span class="n">area_loss</span>
            <span class="o">+</span> <span class="n">weight_eq_residual_loss</span> <span class="o">*</span> <span class="n">loss_eq_residual</span>
            <span class="o">+</span> <span class="n">loss_convex</span>
        <span class="p">)</span>

        <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_eq_residual_loss</span> <span class="o">+=</span> <span class="n">loss_eq_residual</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_chamfer_loss_loss</span> <span class="o">+=</span> <span class="n">weight_chamfer_loss</span> <span class="o">*</span> <span class="n">chamfer_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_convex_loss</span> <span class="o">+=</span> <span class="n">loss_convex</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_convex_loss</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">total_deform_loss</span> <span class="o">+=</span> <span class="n">weight_deform_loss</span> <span class="o">*</span> <span class="n">deform_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">total_inversion_diff_loss</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">inversion_diff_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_diff_loss</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>  <span class="c1"># noqa</span>
        <span class="n">total_inversion_loss</span> <span class="o">+=</span> <span class="n">inversion_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_loss</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># noqa</span>
        <span class="n">total_area_loss</span> <span class="o">+=</span> <span class="n">weight_area_loss</span> <span class="o">*</span> <span class="n">area_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;total_loss&quot;</span><span class="p">:</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
        <span class="s2">&quot;deform_loss&quot;</span><span class="p">:</span> <span class="n">total_deform_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
        <span class="s2">&quot;equation_residual&quot;</span><span class="p">:</span> <span class="n">total_eq_residual_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
        <span class="s2">&quot;chamfer_loss&quot;</span><span class="p">:</span> <span class="n">total_chamfer_loss_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">use_convex_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;convex_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_convex_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_inversion_diff_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_diff_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_diff_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_area_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;area_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_area_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="get_sample_tangle">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.get_sample_tangle">[docs]</a>
<span class="k">def</span> <span class="nf">get_sample_tangle</span><span class="p">(</span><span class="n">out_coords</span><span class="p">,</span> <span class="n">in_coords</span><span class="p">,</span> <span class="n">face</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of tangled elements in a single sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">out_coords</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="n">in_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">in_coords</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="n">out_area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">in_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_area</span>
    <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">out_area</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="n">neg_area</span> <span class="o">=</span> <span class="n">out_area</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span>
    <span class="n">num_tangle</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_area</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num_tangle</span></div>



<div class="viewcode-block" id="count_dataset_tangle">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.count_dataset_tangle">[docs]</a>
<span class="k">def</span> <span class="nf">count_dataset_tangle</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;inversion&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the average number of tangles in a dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (Dataset): The PyTorch Geometric dataset.</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model.</span>
<span class="sd">        device (torch.device): The device to run the computation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The average number of tangles in the dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">num_tangle</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;inversion&quot;</span><span class="p">:</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">loader</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="c1"># # Create mesh query for deformer, seperate from the original mesh as feature for encoder</span>
                <span class="c1"># mesh_query_x = data.mesh_feat[:, 0].view(-1, 1).detach().clone()</span>
                <span class="c1"># mesh_query_y = data.mesh_feat[:, 1].view(-1, 1).detach().clone()</span>
                <span class="c1"># mesh_query_x.requires_grad = True</span>
                <span class="c1"># mesh_query_y.requires_grad = True</span>
                <span class="c1"># mesh_query = torch.cat([mesh_query_x, mesh_query_y], dim=-1)</span>

                <span class="c1"># num_nodes = mesh_query.shape[-2] // bs</span>
                <span class="c1"># # Generate random mesh queries for unsupervised learning</span>
                <span class="c1"># sampled_queries = generate_samples(bs=bs, num_samples_per_mesh=num_nodes, data=data, num_meshes=1, device=device)</span>
                <span class="c1"># sampled_queries_edge_index = construct_graph(sampled_queries[:, :, :2])</span>

                <span class="c1"># mesh_sampled_queries_x = sampled_queries[:, :, 0].view(-1, 1).detach()</span>
                <span class="c1"># mesh_sampled_queries_y = sampled_queries[:, :, 1].view(-1, 1).detach()</span>
                <span class="c1"># mesh_sampled_queries_x.requires_grad = True</span>
                <span class="c1"># mesh_sampled_queries_y.requires_grad = True</span>
                <span class="c1"># mesh_sampled_queries = torch.cat([mesh_sampled_queries_x, mesh_sampled_queries_y], dim=-1).view(-1, 2)</span>

                <span class="c1"># coord_ori_x = data.mesh_feat[:, 0].view(-1, 1)</span>
                <span class="c1"># coord_ori_y = data.mesh_feat[:, 1].view(-1, 1)</span>
                <span class="c1"># coord_ori_x.requires_grad = True</span>
                <span class="c1"># coord_ori_y.requires_grad = True</span>
                <span class="c1"># coord_ori = torch.cat([coord_ori_x, coord_ori_y], dim=-1)</span>

                <span class="c1"># num_nodes = coord_ori.shape[-2] // bs</span>
                <span class="c1"># input_q = torch.cat([mesh_query, data.mesh_feat[:, 2:4]], dim=-1)</span>
                <span class="c1"># input_kv = generate_samples(bs=bs, num_samples_per_mesh=num_nodes, data=data, device=device)</span>
                <span class="c1"># # print(f&quot;batch size: {bs}, num_nodes: {num_nodes}, input q&quot;, input_q.shape, &quot;input_kv &quot;, input_kv.shape)</span>

                <span class="c1"># (output_coord_all, output, out_monitor), (phix, phiy) = model(data.to(device), input_q.to(device), input_q.to(device), mesh_query.to(device), mesh_sampled_queries.to(device), sampled_queries_edge_index)</span>
                <span class="c1"># # (output_coord_all, output, out_monitor), (phix, phiy) = model(data, input_q, input_kv, mesh_query, sampled_queries, sampled_queries_edge_index)</span>
                <span class="c1"># output_data = output_coord_all[:num_nodes*bs]</span>
                <span class="p">(</span>
                    <span class="n">output_coord</span><span class="p">,</span>
                    <span class="n">output</span><span class="p">,</span>
                    <span class="n">out_monitor</span><span class="p">,</span>
                    <span class="n">phix</span><span class="p">,</span>
                    <span class="n">phiy</span><span class="p">,</span>
                    <span class="n">mesh_query_x_all</span><span class="p">,</span>
                    <span class="n">mesh_query_y_all</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">model_forward</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

                <span class="n">out_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">output_coord</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">)</span>
                <span class="n">in_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">x</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">face</span><span class="p">)</span>
                <span class="c1"># restore the sign of the area</span>
                <span class="n">out_area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">in_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_area</span>
                <span class="c1"># mask for negative area</span>
                <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">out_area</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="n">neg_area</span> <span class="o">=</span> <span class="n">out_area</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span>
                <span class="c1"># calculate the loss, we want it normalized by the batch size</span>
                <span class="c1"># and loss should be positive, so we are using -1 here.</span>
                <span class="n">num_tangle</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_area</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num_tangle</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>

    <span class="c1"># deprecated, do not use this option unless you know what you are doing</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;msg&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">output_data</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">input_edge</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">edge_index</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">x</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">mesh_new</span> <span class="o">=</span> <span class="n">output_data</span>
                <span class="n">Counter</span> <span class="o">=</span> <span class="n">TangleCounter</span><span class="p">()</span>
                <span class="n">num_tangle</span> <span class="o">+=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_new</span><span class="p">,</span> <span class="n">input_edge</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">num_tangle</span> <span class="o">=</span> <span class="n">num_tangle</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num_tangle</span></div>



<div class="viewcode-block" id="evaluate_repeat_sampling">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.evaluate_repeat_sampling">[docs]</a>
<span class="k">def</span> <span class="nf">evaluate_repeat_sampling</span><span class="p">(</span>
    <span class="n">dataset</span><span class="p">,</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">device</span><span class="p">,</span>
    <span class="n">loss_func</span><span class="p">,</span>
    <span class="n">use_inversion_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_inversion_diff_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_area_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates a model using the given data loader and loss function.</span>

<span class="sd">    Args:</span>
<span class="sd">        loader (DataLoader): DataLoader object for the evaluation data.</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model to evaluate.</span>
<span class="sd">        device (torch.device): The device to run the computation on.</span>
<span class="sd">        loss_func (callable): Loss function (e.g., MSE, Cross-Entropy).</span>
<span class="sd">        use_jacob (bool): Whether or not to use Jacobian loss. Defaults to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The average evaluation loss across all batches.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">batch_size</span>
    <span class="n">loaders</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">bs</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">data_iters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span> <span class="k">for</span> <span class="n">loader</span> <span class="ow">in</span> <span class="n">loaders</span><span class="p">]</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_area_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loaders</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">data_iter</span><span class="p">)</span> <span class="k">for</span> <span class="n">data_iter</span> <span class="ow">in</span> <span class="n">data_iters</span><span class="p">]</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_diff_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">area_loss</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="n">loss_func</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">use_area_loss</span><span class="p">:</span>
                <span class="n">area_loss</span> <span class="o">=</span> <span class="n">get_area_loss</span><span class="p">(</span>
                    <span class="n">out</span><span class="p">,</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">scaler</span>
                <span class="p">)</span>

            <span class="n">loss</span> <span class="o">=</span> <span class="n">inversion_loss</span> <span class="o">+</span> <span class="n">deform_loss</span>
            <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">total_deform_loss</span> <span class="o">+=</span> <span class="n">deform_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">total_inversion_diff_loss</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">inversion_diff_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_diff_loss</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="p">)</span>  <span class="c1"># noqa</span>
            <span class="n">total_inversion_loss</span> <span class="o">+=</span> <span class="n">inversion_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_inversion_loss</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># noqa</span>
            <span class="n">total_area_loss</span> <span class="o">+=</span> <span class="n">area_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_area_loss</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;total_loss&quot;</span><span class="p">:</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loaders</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="s2">&quot;deform_loss&quot;</span><span class="p">:</span> <span class="n">total_deform_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loaders</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">use_inversion_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loaders</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">use_inversion_diff_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;inversion_diff_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_inversion_diff_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loaders</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># noqa</span>
    <span class="k">if</span> <span class="n">use_area_loss</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;area_loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_area_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">loaders</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="count_dataset_tangle_repeat_sampling">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.count_dataset_tangle_repeat_sampling">[docs]</a>
<span class="k">def</span> <span class="nf">count_dataset_tangle_repeat_sampling</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the average number of tangles in a dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (Dataset): The PyTorch Geometric dataset.</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model.</span>
<span class="sd">        device (torch.device): The device to run the computation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The average number of tangles in the dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">num_tangle</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">loaders</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">data_iters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span> <span class="k">for</span> <span class="n">loader</span> <span class="ow">in</span> <span class="n">loaders</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loaders</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">data_iter</span><span class="p">)</span> <span class="k">for</span> <span class="n">data_iter</span> <span class="ow">in</span> <span class="n">data_iters</span><span class="p">]</span>
            <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]</span>
            <span class="n">output_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">))</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]</span>
            <span class="n">output_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">output_data</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">output_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">output_data</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">out_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">output_data</span><span class="p">,</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">face</span><span class="p">)</span>
            <span class="n">in_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">face</span><span class="p">)</span>
            <span class="c1"># restore the sign of the area</span>
            <span class="n">out_area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">in_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_area</span>
            <span class="c1"># mask for negative area</span>
            <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">out_area</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">neg_area</span> <span class="o">=</span> <span class="n">out_area</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span>
            <span class="c1"># calculate the loss, we want it normalized by the batch size</span>
            <span class="c1"># and loss should be positive, so we are using -1 here.</span>
            <span class="n">num_tangle</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_area</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num_tangle</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span></div>



<div class="viewcode-block" id="evaluate_repeat">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.evaluate_repeat">[docs]</a>
<span class="k">def</span> <span class="nf">evaluate_repeat</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">num_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates model performance when sampling for different number of times.</span>
<span class="sd">    this function will evaluate:</span>
<span class="sd">        1. the average loss</span>
<span class="sd">        2. the average number of tangles</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (MeshDataset): The target dataset to evaluate.</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model to evaluate.</span>
<span class="sd">        device (torch.device): The device to run the computation on.</span>
<span class="sd">        loss_func (callable): Loss function (e.g., MSE, Cross-Entropy).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The average evaluation loss across all batches.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">loaders</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_repeat</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">data_iters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span> <span class="k">for</span> <span class="n">loader</span> <span class="ow">in</span> <span class="n">loaders</span><span class="p">]</span>

    <span class="n">num_tangle</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_area_loss</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loaders</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">data_iter</span><span class="p">)</span> <span class="k">for</span> <span class="n">data_iter</span> <span class="ow">in</span> <span class="n">data_iters</span><span class="p">]</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inversion_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">area_loss</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># calculate the loss</span>
            <span class="n">deform_loss</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="n">loss_func</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            <span class="n">area_loss</span> <span class="o">=</span> <span class="n">get_area_loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">face</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scaler</span><span class="p">)</span>

            <span class="n">loss</span> <span class="o">=</span> <span class="n">inversion_loss</span> <span class="o">+</span> <span class="n">deform_loss</span>
            <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">total_deform_loss</span> <span class="o">+=</span> <span class="n">deform_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">total_area_loss</span> <span class="o">+=</span> <span class="n">area_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="c1"># calculate the number of tangles</span>
            <span class="n">in_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">face</span><span class="p">)</span>
            <span class="n">out_area</span> <span class="o">=</span> <span class="n">get_face_area</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">face</span><span class="p">)</span>
            <span class="n">out_area</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">in_area</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_area</span>
            <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">out_area</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">neg_area</span> <span class="o">=</span> <span class="n">out_area</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span>
            <span class="n">num_tangle</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_area</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;total_loss&quot;</span><span class="p">:</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">),</span>
        <span class="s2">&quot;deform_loss&quot;</span><span class="p">:</span> <span class="n">total_deform_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">),</span>
        <span class="s2">&quot;tangle&quot;</span><span class="p">:</span> <span class="n">num_tangle</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">),</span>
        <span class="s2">&quot;area_loss&quot;</span><span class="p">:</span> <span class="n">total_area_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">),</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="load_model">
<a class="viewcode-back" href="../../../UM2N.model.html#UM2N.model.train_util.load_model">[docs]</a>
<span class="k">def</span> <span class="nf">load_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">weight_path</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads pre-trained weights into a PyTorch model from a given file path.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (torch.nn.Module): The PyTorch model.</span>
<span class="sd">        weight_path (str): File path to the pre-trained model weights.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.nn.Module: The model with loaded weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">weight_path</span><span class="p">),</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="n">state_dict</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">weight_path</span><span class="p">,</span> <span class="n">map_location</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">))</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Animate, Movement, Goalie and UM2N 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">UM2N.model.train_util</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021-2024, Joseph G. Wallwork et al..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    </div>
  </body>
</html>